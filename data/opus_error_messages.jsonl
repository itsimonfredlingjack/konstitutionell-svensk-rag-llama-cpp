{"instruction": "Write a function that parses a config file and handles errors", "output": "Here's how to write helpful error messages when parsing config:\n\n```python\nfrom pathlib import Path\nfrom typing import Any\nimport json\nimport yaml\n\nclass ConfigError(Exception):\n    \"\"\"Base configuration error with helpful context.\"\"\"\n    pass\n\nclass ConfigFileNotFoundError(ConfigError):\n    \"\"\"Config file doesn't exist.\"\"\"\n    def __init__(self, path: Path, searched_locations: list[Path] = None):\n        self.path = path\n        self.searched_locations = searched_locations or []\n        \n        msg = f\"Config file not found: {path}\"\n        \n        if self.searched_locations:\n            msg += f\"\\n\\nSearched locations:\\n\"\n            for loc in self.searched_locations:\n                exists = \"✓ exists\" if loc.exists() else \"✗ not found\"\n                msg += f\"  - {loc} ({exists})\\n\"\n        \n        msg += f\"\\nTo fix: Create the config file or set CONFIG_PATH environment variable.\"\n        \n        super().__init__(msg)\n\nclass ConfigParseError(ConfigError):\n    \"\"\"Config file has invalid syntax.\"\"\"\n    def __init__(self, path: Path, line: int = None, column: int = None, detail: str = None):\n        self.path = path\n        self.line = line\n        self.column = column\n        \n        msg = f\"Failed to parse config file: {path}\"\n        \n        if line:\n            msg += f\" at line {line}\"\n            if column:\n                msg += f\", column {column}\"\n        \n        if detail:\n            msg += f\"\\n\\nError: {detail}\"\n        \n        # Show the problematic line if possible\n        if line and path.exists():\n            try:\n                lines = path.read_text().splitlines()\n                if 0 < line <= len(lines):\n                    problem_line = lines[line - 1]\n                    msg += f\"\\n\\nProblematic line {line}:\\n  {problem_line}\"\n                    if column:\n                        msg += f\"\\n  {' ' * (column - 1)}^\"\n            except:\n                pass\n        \n        msg += f\"\\n\\nTo fix: Check the syntax of your config file. \"\n        if str(path).endswith('.json'):\n            msg += \"Validate at https://jsonlint.com/\"\n        elif str(path).endswith(('.yml', '.yaml')):\n            msg += \"Validate at https://yamlvalidator.com/\"\n        \n        super().__init__(msg)\n\nclass ConfigValidationError(ConfigError):\n    \"\"\"Config values are invalid.\"\"\"\n    def __init__(self, field: str, value: Any, expected: str, path: Path = None):\n        self.field = field\n        self.value = value\n        self.expected = expected\n        \n        msg = f\"Invalid config value for '{field}'\\n\"\n        msg += f\"  Got: {repr(value)} ({type(value).__name__})\\n\"\n        msg += f\"  Expected: {expected}\\n\"\n        \n        if path:\n            msg += f\"  File: {path}\\n\"\n        \n        # Suggest fixes based on common mistakes\n        if expected == 'int' and isinstance(value, str):\n            if value.isdigit():\n                msg += f\"\\nTo fix: Remove quotes around the number: {field}: {value}\"\n            else:\n                msg += f\"\\nTo fix: Use a valid integer, e.g., {field}: 8080\"\n        elif expected == 'bool' and isinstance(value, str):\n            msg += f\"\\nTo fix: Use true/false without quotes: {field}: true\"\n        elif 'url' in expected.lower() and isinstance(value, str):\n            if not value.startswith(('http://', 'https://')):\n                msg += f\"\\nTo fix: Add protocol: {field}: https://{value}\"\n        \n        super().__init__(msg)\n\nclass ConfigMissingKeyError(ConfigError):\n    \"\"\"Required config key is missing.\"\"\"\n    def __init__(self, key: str, available_keys: list[str] = None, path: Path = None):\n        self.key = key\n        \n        msg = f\"Required config key missing: '{key}'\"\n        \n        if path:\n            msg += f\" in {path}\"\n        \n        if available_keys:\n            # Check for typos\n            similar = self._find_similar(key, available_keys)\n            if similar:\n                msg += f\"\\n\\nDid you mean: '{similar}'?\"\n            \n            msg += f\"\\n\\nAvailable keys: {', '.join(sorted(available_keys))}\"\n        \n        msg += f\"\\n\\nTo fix: Add the '{key}' key to your config file.\"\n        \n        super().__init__(msg)\n    \n    @staticmethod\n    def _find_similar(key: str, candidates: list[str]) -> str:\n        \"\"\"Find most similar key (simple Levenshtein).\"\"\"\n        key_lower = key.lower()\n        for candidate in candidates:\n            if candidate.lower().startswith(key_lower[:3]):\n                return candidate\n            if key_lower in candidate.lower():\n                return candidate\n        return None\n\ndef load_config(path: Path) -> dict:\n    \"\"\"Load and validate config with helpful errors.\"\"\"\n    \n    # Check file exists\n    if not path.exists():\n        search_paths = [\n            Path.cwd() / 'config.json',\n            Path.cwd() / 'config.yml',\n            Path.home() / '.config' / 'myapp' / 'config.json',\n        ]\n        raise ConfigFileNotFoundError(path, search_paths)\n    \n    # Parse file\n    content = path.read_text()\n    \n    try:\n        if path.suffix == '.json':\n            config = json.loads(content)\n        elif path.suffix in ('.yml', '.yaml'):\n            config = yaml.safe_load(content)\n        else:\n            raise ConfigError(f\"Unknown config format: {path.suffix}. Use .json or .yml\")\n    \n    except json.JSONDecodeError as e:\n        raise ConfigParseError(path, e.lineno, e.colno, e.msg)\n    except yaml.YAMLError as e:\n        line = e.problem_mark.line + 1 if hasattr(e, 'problem_mark') else None\n        raise ConfigParseError(path, line, detail=str(e))\n    \n    # Validate required keys\n    required = ['database_url', 'api_port', 'secret_key']\n    for key in required:\n        if key not in config:\n            raise ConfigMissingKeyError(key, list(config.keys()), path)\n    \n    # Validate types\n    if not isinstance(config.get('api_port'), int):\n        raise ConfigValidationError('api_port', config['api_port'], 'int', path)\n    \n    if not config.get('database_url', '').startswith(('postgres://', 'postgresql://')):\n        raise ConfigValidationError(\n            'database_url', \n            config['database_url'], \n            'PostgreSQL URL (postgresql://user:pass@host:port/db)',\n            path\n        )\n    \n    return config\n```\n\nKey error message principles:\n1. **What went wrong** - Clear description of the error\n2. **Where it happened** - File, line, column when possible\n3. **What was expected** - Show valid format/values\n4. **How to fix it** - Actionable next steps\n5. **Context** - Show available options, similar keys, etc."}
{"instruction": "Write an API endpoint that validates input", "output": "Here's how to return helpful validation errors from an API:\n\n```python\nfrom fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel, validator, Field\nfrom typing import Optional, Any\nfrom dataclasses import dataclass\nimport re\n\napp = FastAPI()\n\n@dataclass\nclass APIError:\n    \"\"\"Structured API error response.\"\"\"\n    code: str\n    message: str\n    field: Optional[str] = None\n    received: Optional[Any] = None\n    expected: Optional[str] = None\n    suggestion: Optional[str] = None\n    docs_url: Optional[str] = None\n\nclass APIErrorResponse(BaseModel):\n    \"\"\"Standard error response format.\"\"\"\n    error: str\n    message: str\n    details: list[dict] = []\n    request_id: Optional[str] = None\n    docs: Optional[str] = None\n\nclass CreateUserRequest(BaseModel):\n    email: str = Field(..., description=\"User's email address\")\n    password: str = Field(..., min_length=8, description=\"Minimum 8 characters\")\n    age: Optional[int] = Field(None, ge=13, le=120, description=\"User's age (13-120)\")\n    username: str = Field(..., min_length=3, max_length=20)\n    \n    @validator('email')\n    def validate_email(cls, v):\n        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n        if not re.match(pattern, v):\n            raise ValueError(\n                f\"Invalid email format. \"\n                f\"Got '{v}'. \"\n                f\"Expected format: user@example.com\"\n            )\n        return v.lower()\n    \n    @validator('password')\n    def validate_password(cls, v):\n        errors = []\n        \n        if len(v) < 8:\n            errors.append(f\"at least 8 characters (got {len(v)})\")\n        if not re.search(r'[A-Z]', v):\n            errors.append(\"at least one uppercase letter\")\n        if not re.search(r'[a-z]', v):\n            errors.append(\"at least one lowercase letter\")\n        if not re.search(r'\\d', v):\n            errors.append(\"at least one number\")\n        \n        if errors:\n            raise ValueError(\n                f\"Password must contain: {', '.join(errors)}. \"\n                f\"Example of valid password: 'MySecure123'\"\n            )\n        return v\n    \n    @validator('username')\n    def validate_username(cls, v):\n        if not re.match(r'^[a-zA-Z][a-zA-Z0-9_]*$', v):\n            if v[0].isdigit():\n                raise ValueError(\n                    f\"Username cannot start with a number. \"\n                    f\"Got '{v}'. Try '{v[1:]}' or 'user_{v}' instead.\"\n                )\n            invalid_chars = set(re.findall(r'[^a-zA-Z0-9_]', v))\n            raise ValueError(\n                f\"Username contains invalid characters: {invalid_chars}. \"\n                f\"Only letters, numbers, and underscores allowed. \"\n                f\"Try: '{re.sub(r'[^a-zA-Z0-9_]', '_', v)}'\"\n            )\n        return v\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler(request: Request, exc: HTTPException):\n    \"\"\"Format HTTP exceptions with helpful details.\"\"\"\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\n            'error': _get_error_code(exc.status_code),\n            'message': exc.detail,\n            'status_code': exc.status_code,\n            'path': str(request.url.path),\n            'method': request.method,\n            'docs': 'https://api.example.com/docs#errors'\n        }\n    )\n\nfrom fastapi.exceptions import RequestValidationError\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(request: Request, exc: RequestValidationError):\n    \"\"\"Transform Pydantic errors into helpful messages.\"\"\"\n    errors = []\n    \n    for error in exc.errors():\n        field = '.'.join(str(loc) for loc in error['loc'] if loc != 'body')\n        msg = error['msg']\n        error_type = error['type']\n        \n        detail = {\n            'field': field,\n            'message': msg,\n            'code': error_type,\n        }\n        \n        # Add context based on error type\n        if error_type == 'value_error.missing':\n            detail['suggestion'] = f\"Add '{field}' to your request body\"\n            detail['example'] = _get_field_example(field)\n        \n        elif error_type == 'type_error.integer':\n            detail['suggestion'] = f\"'{field}' must be a number without quotes\"\n            detail['example'] = f'\"{field}\": 25'\n        \n        elif 'min_length' in error_type:\n            detail['suggestion'] = f\"'{field}' is too short\"\n        \n        elif 'max_length' in error_type:\n            detail['suggestion'] = f\"'{field}' is too long\"\n        \n        errors.append(detail)\n    \n    return JSONResponse(\n        status_code=422,\n        content={\n            'error': 'validation_error',\n            'message': f'Request validation failed with {len(errors)} error(s)',\n            'details': errors,\n            'docs': 'https://api.example.com/docs#create-user',\n            'example_request': {\n                'email': 'user@example.com',\n                'password': 'SecurePass123',\n                'username': 'johndoe',\n                'age': 25\n            }\n        }\n    )\n\ndef _get_error_code(status_code: int) -> str:\n    codes = {\n        400: 'bad_request',\n        401: 'unauthorized',\n        403: 'forbidden',\n        404: 'not_found',\n        409: 'conflict',\n        422: 'validation_error',\n        429: 'rate_limited',\n        500: 'internal_error',\n    }\n    return codes.get(status_code, 'error')\n\ndef _get_field_example(field: str) -> str:\n    examples = {\n        'email': '\"email\": \"user@example.com\"',\n        'password': '\"password\": \"SecurePass123\"',\n        'username': '\"username\": \"johndoe\"',\n        'age': '\"age\": 25',\n    }\n    return examples.get(field, f'\"{field}\": \"...\"')\n\n@app.post('/users')\nasync def create_user(user: CreateUserRequest):\n    # Check if email already exists\n    if await email_exists(user.email):\n        raise HTTPException(\n            status_code=409,\n            detail=(\n                f\"Email '{user.email}' is already registered. \"\n                f\"Did you mean to login? Try POST /auth/login. \"\n                f\"Or use a different email address.\"\n            )\n        )\n    \n    # Check username availability\n    if await username_exists(user.username):\n        suggestions = await get_username_suggestions(user.username)\n        raise HTTPException(\n            status_code=409,\n            detail=(\n                f\"Username '{user.username}' is taken. \"\n                f\"Try one of these: {', '.join(suggestions)}\"\n            )\n        )\n    \n    return {'id': 1, 'email': user.email, 'username': user.username}\n```\n\nKey principles for API error messages:\n1. **Structured format** - Consistent error response schema\n2. **Error codes** - Machine-readable codes for client handling\n3. **Field-level errors** - Point to exact problematic field\n4. **Examples** - Show what valid input looks like\n5. **Suggestions** - Offer alternatives (available usernames, etc.)\n6. **Docs links** - Point to relevant documentation"}
{"instruction": "Write a function that connects to a database", "output": "Here's how to handle database connection errors helpfully:\n\n```python\nimport asyncpg\nimport logging\nfrom typing import Optional\nfrom dataclasses import dataclass\nfrom urllib.parse import urlparse\nimport socket\nimport asyncio\n\nlogger = logging.getLogger(__name__)\n\nclass DatabaseConnectionError(Exception):\n    \"\"\"Base class for database connection errors.\"\"\"\n    pass\n\nclass DatabaseHostUnreachableError(DatabaseConnectionError):\n    \"\"\"Cannot reach the database server.\"\"\"\n    def __init__(self, host: str, port: int, original_error: Exception = None):\n        self.host = host\n        self.port = port\n        \n        msg = f\"Cannot connect to database server at {host}:{port}\\n\"\n        msg += \"\\nPossible causes:\\n\"\n        msg += f\"  1. Database server is not running\\n\"\n        msg += f\"  2. Wrong host/port (check DATABASE_URL)\\n\"\n        msg += f\"  3. Firewall blocking connection\\n\"\n        msg += f\"  4. Network issue\\n\"\n        \n        msg += \"\\nDiagnostic steps:\\n\"\n        msg += f\"  - Check if server is running: pg_isready -h {host} -p {port}\\n\"\n        msg += f\"  - Test connectivity: nc -zv {host} {port}\\n\"\n        msg += f\"  - Check your DATABASE_URL environment variable\\n\"\n        \n        if original_error:\n            msg += f\"\\nOriginal error: {original_error}\"\n        \n        super().__init__(msg)\n\nclass DatabaseAuthenticationError(DatabaseConnectionError):\n    \"\"\"Authentication failed.\"\"\"\n    def __init__(self, user: str, database: str, auth_method: str = None):\n        self.user = user\n        self.database = database\n        \n        msg = f\"Authentication failed for user '{user}' on database '{database}'\\n\"\n        msg += \"\\nPossible causes:\\n\"\n        msg += f\"  1. Wrong password\\n\"\n        msg += f\"  2. User '{user}' doesn't exist\\n\"\n        msg += f\"  3. User lacks permission for database '{database}'\\n\"\n        \n        if auth_method:\n            msg += f\"  4. Auth method mismatch (server expects: {auth_method})\\n\"\n        \n        msg += \"\\nTo fix:\\n\"\n        msg += f\"  - Verify credentials in DATABASE_URL\\n\"\n        msg += f\"  - Check user exists: psql -c \\\"SELECT usename FROM pg_user WHERE usename='{user}'\\\"\\n\"\n        msg += f\"  - Check pg_hba.conf authentication settings\\n\"\n        \n        super().__init__(msg)\n\nclass DatabaseNotFoundError(DatabaseConnectionError):\n    \"\"\"Database doesn't exist.\"\"\"\n    def __init__(self, database: str, available: list[str] = None):\n        self.database = database\n        \n        msg = f\"Database '{database}' does not exist\\n\"\n        \n        if available:\n            msg += f\"\\nAvailable databases: {', '.join(available)}\\n\"\n            \n            # Check for typos\n            for db in available:\n                if db.lower() == database.lower():\n                    msg += f\"\\nDid you mean '{db}'? (case mismatch)\\n\"\n                    break\n        \n        msg += \"\\nTo fix:\\n\"\n        msg += f\"  - Create the database: createdb {database}\\n\"\n        msg += f\"  - Or update DATABASE_URL to use an existing database\\n\"\n        \n        super().__init__(msg)\n\nclass DatabaseSSLError(DatabaseConnectionError):\n    \"\"\"SSL/TLS connection issue.\"\"\"\n    def __init__(self, detail: str, require_ssl: bool = True):\n        msg = f\"SSL connection error: {detail}\\n\"\n        \n        if require_ssl:\n            msg += \"\\nPossible causes:\\n\"\n            msg += \"  1. Server doesn't support SSL\\n\"\n            msg += \"  2. SSL certificate verification failed\\n\"\n            msg += \"  3. Wrong SSL mode in connection string\\n\"\n            msg += \"\\nTo fix:\\n\"\n            msg += \"  - Try adding '?sslmode=require' to DATABASE_URL\\n\"\n            msg += \"  - Or '?sslmode=disable' if SSL not needed (dev only!)\\n\"\n        \n        super().__init__(msg)\n\n@dataclass\nclass DatabaseURL:\n    \"\"\"Parsed database URL with validation.\"\"\"\n    host: str\n    port: int\n    database: str\n    user: str\n    password: str\n    ssl_mode: str = 'prefer'\n    \n    @classmethod\n    def parse(cls, url: str) -> 'DatabaseURL':\n        \"\"\"Parse DATABASE_URL with helpful errors.\"\"\"\n        if not url:\n            raise DatabaseConnectionError(\n                \"DATABASE_URL is empty or not set.\\n\\n\"\n                \"To fix:\\n\"\n                \"  export DATABASE_URL='postgresql://user:pass@localhost:5432/mydb'\\n\\n\"\n                \"Or add to .env file:\\n\"\n                \"  DATABASE_URL=postgresql://user:pass@localhost:5432/mydb\"\n            )\n        \n        if not url.startswith(('postgres://', 'postgresql://')):\n            raise DatabaseConnectionError(\n                f\"Invalid DATABASE_URL format.\\n\\n\"\n                f\"Got: {url[:50]}...\\n\"\n                f\"Expected: postgresql://user:password@host:port/database\\n\\n\"\n                f\"Make sure it starts with 'postgresql://' or 'postgres://'\"\n            )\n        \n        try:\n            parsed = urlparse(url)\n            \n            if not parsed.hostname:\n                raise DatabaseConnectionError(\n                    f\"Missing host in DATABASE_URL.\\n\"\n                    f\"Got: {url}\\n\"\n                    f\"Expected: postgresql://user:pass@HOST:port/db\"\n                )\n            \n            if not parsed.path or parsed.path == '/':\n                raise DatabaseConnectionError(\n                    f\"Missing database name in DATABASE_URL.\\n\"\n                    f\"Got: {url}\\n\"\n                    f\"Expected: postgresql://user:pass@host:port/DATABASE\"\n                )\n            \n            return cls(\n                host=parsed.hostname,\n                port=parsed.port or 5432,\n                database=parsed.path.lstrip('/'),\n                user=parsed.username or 'postgres',\n                password=parsed.password or '',\n                ssl_mode=dict(q.split('=') for q in parsed.query.split('&') if '=' in q).get('sslmode', 'prefer')\n            )\n        \n        except Exception as e:\n            raise DatabaseConnectionError(\n                f\"Cannot parse DATABASE_URL: {e}\\n\\n\"\n                f\"URL: {url[:50]}...\\n\"\n                f\"Format: postgresql://user:password@host:port/database?sslmode=require\"\n            )\n\nasync def connect_database(url: str, timeout: float = 10.0) -> asyncpg.Pool:\n    \"\"\"\n    Connect to database with helpful error messages.\n    \n    Args:\n        url: PostgreSQL connection URL\n        timeout: Connection timeout in seconds\n    \n    Returns:\n        Connection pool\n    \n    Raises:\n        DatabaseConnectionError: With helpful diagnostic info\n    \"\"\"\n    db_url = DatabaseURL.parse(url)\n    \n    # First, check if host is reachable\n    try:\n        sock = socket.create_connection((db_url.host, db_url.port), timeout=5)\n        sock.close()\n    except socket.timeout:\n        raise DatabaseHostUnreachableError(db_url.host, db_url.port, \"Connection timed out\")\n    except socket.error as e:\n        raise DatabaseHostUnreachableError(db_url.host, db_url.port, e)\n    \n    # Try to connect\n    try:\n        pool = await asyncio.wait_for(\n            asyncpg.create_pool(\n                url,\n                min_size=2,\n                max_size=10,\n            ),\n            timeout=timeout\n        )\n        \n        # Test the connection\n        async with pool.acquire() as conn:\n            await conn.execute('SELECT 1')\n        \n        logger.info(f\"Connected to database '{db_url.database}' at {db_url.host}:{db_url.port}\")\n        return pool\n    \n    except asyncio.TimeoutError:\n        raise DatabaseConnectionError(\n            f\"Connection timed out after {timeout}s.\\n\\n\"\n            f\"The server at {db_url.host}:{db_url.port} is reachable but not responding.\\n\"\n            f\"This could mean:\\n\"\n            f\"  - Database is overloaded\\n\"\n            f\"  - Too many connections\\n\"\n            f\"  - Slow authentication (check pg_hba.conf)\\n\"\n        )\n    \n    except asyncpg.InvalidPasswordError:\n        raise DatabaseAuthenticationError(db_url.user, db_url.database)\n    \n    except asyncpg.InvalidCatalogNameError:\n        # Try to list available databases\n        try:\n            temp_conn = await asyncpg.connect(\n                host=db_url.host,\n                port=db_url.port,\n                user=db_url.user,\n                password=db_url.password,\n                database='postgres'\n            )\n            rows = await temp_conn.fetch(\"SELECT datname FROM pg_database WHERE datistemplate = false\")\n            available = [row['datname'] for row in rows]\n            await temp_conn.close()\n        except:\n            available = None\n        \n        raise DatabaseNotFoundError(db_url.database, available)\n    \n    except Exception as e:\n        if 'SSL' in str(e) or 'ssl' in str(e):\n            raise DatabaseSSLError(str(e))\n        \n        raise DatabaseConnectionError(\n            f\"Database connection failed: {e}\\n\\n\"\n            f\"Connection details:\\n\"\n            f\"  Host: {db_url.host}\\n\"\n            f\"  Port: {db_url.port}\\n\"\n            f\"  Database: {db_url.database}\\n\"\n            f\"  User: {db_url.user}\\n\"\n            f\"  SSL: {db_url.ssl_mode}\\n\"\n        )\n```\n\nKey principles:\n1. **Specific exception types** for different failure modes\n2. **Diagnostic info** - what to check, commands to run\n3. **Context** - show the values that failed\n4. **Suggestions** - offer alternatives and fixes\n5. **Pre-flight checks** - verify connectivity before attempting connection"}
{"instruction": "Write a file upload handler", "output": "Here's how to handle file upload errors helpfully:\n\n```python\nfrom fastapi import FastAPI, UploadFile, HTTPException\nfrom pathlib import Path\nfrom typing import Optional\nimport magic\nimport hashlib\n\napp = FastAPI()\n\nclass FileUploadError(Exception):\n    \"\"\"Base file upload error.\"\"\"\n    def __init__(self, message: str, code: str, details: dict = None):\n        self.message = message\n        self.code = code\n        self.details = details or {}\n        super().__init__(message)\n\nclass FileTooLargeError(FileUploadError):\n    \"\"\"File exceeds size limit.\"\"\"\n    def __init__(self, size: int, max_size: int, filename: str):\n        size_mb = size / (1024 * 1024)\n        max_mb = max_size / (1024 * 1024)\n        \n        super().__init__(\n            message=(\n                f\"File '{filename}' is too large ({size_mb:.1f} MB). \"\n                f\"Maximum allowed size is {max_mb:.0f} MB.\\n\\n\"\n                f\"To upload this file:\\n\"\n                f\"  - Compress the file (zip, gzip)\\n\"\n                f\"  - Reduce image resolution if it's an image\\n\"\n                f\"  - Split into smaller parts\\n\"\n                f\"  - Contact support for increased limit\"\n            ),\n            code='file_too_large',\n            details={\n                'size_bytes': size,\n                'max_bytes': max_size,\n                'size_mb': round(size_mb, 2),\n                'max_mb': round(max_mb, 0),\n                'filename': filename\n            }\n        )\n\nclass InvalidFileTypeError(FileUploadError):\n    \"\"\"File type not allowed.\"\"\"\n    def __init__(\n        self, \n        filename: str, \n        detected_type: str, \n        allowed_types: list[str],\n        detected_extension: str = None\n    ):\n        allowed_str = ', '.join(allowed_types)\n        \n        message = f\"File type not allowed for '{filename}'.\\n\\n\"\n        message += f\"  Detected type: {detected_type}\\n\"\n        \n        if detected_extension:\n            message += f\"  File extension: {detected_extension}\\n\"\n            \n            # Check for extension mismatch\n            if detected_extension.lower() not in detected_type.lower():\n                message += f\"\\n⚠️  Warning: Extension doesn't match content type.\\n\"\n                message += f\"   The file claims to be '{detected_extension}' but contains '{detected_type}'.\\n\"\n                message += f\"   This could indicate a renamed file or potential security issue.\\n\"\n        \n        message += f\"\\nAllowed types: {allowed_str}\\n\"\n        \n        # Suggest alternatives\n        if 'image' in detected_type:\n            if 'image/png' in allowed_types or 'image/jpeg' in allowed_types:\n                message += \"\\nTry converting your image to PNG or JPEG format.\"\n        elif 'pdf' in detected_type.lower() and 'application/pdf' not in allowed_types:\n            message += \"\\nPDF files are not accepted. Try converting to an allowed format.\"\n        \n        super().__init__(\n            message=message,\n            code='invalid_file_type',\n            details={\n                'filename': filename,\n                'detected_type': detected_type,\n                'detected_extension': detected_extension,\n                'allowed_types': allowed_types\n            }\n        )\n\nclass EmptyFileError(FileUploadError):\n    \"\"\"File is empty.\"\"\"\n    def __init__(self, filename: str):\n        super().__init__(\n            message=(\n                f\"File '{filename}' is empty (0 bytes).\\n\\n\"\n                f\"This could mean:\\n\"\n                f\"  - The file wasn't selected properly\\n\"\n                f\"  - Upload was interrupted\\n\"\n                f\"  - The original file is empty\\n\\n\"\n                f\"Please select the file again and retry.\"\n            ),\n            code='empty_file',\n            details={'filename': filename}\n        )\n\nclass DuplicateFileError(FileUploadError):\n    \"\"\"File already exists.\"\"\"\n    def __init__(self, filename: str, existing_path: str, existing_id: str = None):\n        message = f\"A file with the same content already exists.\\n\\n\"\n        message += f\"  Uploaded: {filename}\\n\"\n        message += f\"  Existing: {existing_path}\\n\"\n        \n        if existing_id:\n            message += f\"  File ID: {existing_id}\\n\"\n            message += f\"\\nYou can use the existing file instead of uploading again.\"\n        \n        super().__init__(\n            message=message,\n            code='duplicate_file',\n            details={\n                'filename': filename,\n                'existing_path': existing_path,\n                'existing_id': existing_id\n            }\n        )\n\nclass FileUploadConfig:\n    MAX_SIZE = 10 * 1024 * 1024  # 10 MB\n    ALLOWED_TYPES = [\n        'image/jpeg', 'image/png', 'image/gif', 'image/webp',\n        'application/pdf',\n        'text/plain', 'text/csv',\n    ]\n    ALLOWED_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.pdf', '.txt', '.csv']\n\nasync def validate_upload(file: UploadFile) -> tuple[bytes, str]:\n    \"\"\"\n    Validate uploaded file with helpful errors.\n    \n    Returns:\n        Tuple of (file_content, detected_mime_type)\n    \"\"\"\n    filename = file.filename or 'unknown'\n    extension = Path(filename).suffix.lower() if filename else None\n    \n    # Read content\n    content = await file.read()\n    \n    # Check for empty file\n    if len(content) == 0:\n        raise EmptyFileError(filename)\n    \n    # Check size\n    if len(content) > FileUploadConfig.MAX_SIZE:\n        raise FileTooLargeError(len(content), FileUploadConfig.MAX_SIZE, filename)\n    \n    # Detect actual file type (not just extension)\n    detected_type = magic.from_buffer(content, mime=True)\n    \n    # Check if type is allowed\n    if detected_type not in FileUploadConfig.ALLOWED_TYPES:\n        raise InvalidFileTypeError(\n            filename=filename,\n            detected_type=detected_type,\n            allowed_types=FileUploadConfig.ALLOWED_TYPES,\n            detected_extension=extension\n        )\n    \n    # Check extension matches content (security)\n    if extension:\n        expected_extensions = {\n            'image/jpeg': ['.jpg', '.jpeg'],\n            'image/png': ['.png'],\n            'image/gif': ['.gif'],\n            'application/pdf': ['.pdf'],\n        }\n        \n        valid_extensions = expected_extensions.get(detected_type, [])\n        if valid_extensions and extension not in valid_extensions:\n            raise InvalidFileTypeError(\n                filename=filename,\n                detected_type=detected_type,\n                allowed_types=FileUploadConfig.ALLOWED_TYPES,\n                detected_extension=extension\n            )\n    \n    # Check for duplicates (by content hash)\n    content_hash = hashlib.sha256(content).hexdigest()\n    existing = await find_file_by_hash(content_hash)  # Your lookup function\n    \n    if existing:\n        raise DuplicateFileError(\n            filename=filename,\n            existing_path=existing['path'],\n            existing_id=existing['id']\n        )\n    \n    return content, detected_type\n\n@app.post('/upload')\nasync def upload_file(file: UploadFile):\n    \"\"\"Upload a file with validation.\"\"\"\n    try:\n        content, mime_type = await validate_upload(file)\n        \n        # Save file...\n        return {\n            'filename': file.filename,\n            'size': len(content),\n            'type': mime_type,\n            'message': 'Upload successful'\n        }\n    \n    except FileUploadError as e:\n        raise HTTPException(\n            status_code=400,\n            detail={\n                'error': e.code,\n                'message': e.message,\n                'details': e.details\n            }\n        )\n```\n\nKey error handling patterns:\n1. **Size errors** - Show current vs max, suggest compression\n2. **Type errors** - Detect actual type vs extension mismatch\n3. **Empty files** - Explain why this might happen\n4. **Duplicates** - Offer to use existing file\n5. **Security** - Check content matches extension (prevent .exe disguised as .jpg)"}
{"instruction": "Write a function that makes HTTP requests to external APIs", "output": "Here's how to handle external API errors helpfully:\n\n```python\nimport httpx\nimport logging\nfrom typing import Optional, Any, Type\nfrom dataclasses import dataclass\nfrom enum import Enum\nimport json\n\nlogger = logging.getLogger(__name__)\n\nclass APIErrorCategory(Enum):\n    NETWORK = 'network'\n    AUTHENTICATION = 'authentication'\n    AUTHORIZATION = 'authorization'\n    NOT_FOUND = 'not_found'\n    RATE_LIMITED = 'rate_limited'\n    SERVER_ERROR = 'server_error'\n    INVALID_REQUEST = 'invalid_request'\n    TIMEOUT = 'timeout'\n\n@dataclass\nclass APIErrorContext:\n    \"\"\"Context for API errors.\"\"\"\n    service: str\n    endpoint: str\n    method: str\n    status_code: Optional[int] = None\n    response_body: Optional[str] = None\n    request_id: Optional[str] = None\n\nclass ExternalAPIError(Exception):\n    \"\"\"Base class for external API errors with helpful diagnostics.\"\"\"\n    \n    category: APIErrorCategory = APIErrorCategory.SERVER_ERROR\n    \n    def __init__(self, message: str, context: APIErrorContext, original_error: Exception = None):\n        self.context = context\n        self.original_error = original_error\n        \n        # Build detailed message\n        full_message = f\"{message}\\n\"\n        full_message += f\"\\nAPI Details:\\n\"\n        full_message += f\"  Service: {context.service}\\n\"\n        full_message += f\"  Endpoint: {context.method} {context.endpoint}\\n\"\n        \n        if context.status_code:\n            full_message += f\"  Status: {context.status_code}\\n\"\n        \n        if context.request_id:\n            full_message += f\"  Request ID: {context.request_id}\\n\"\n        \n        if context.response_body:\n            # Try to extract error message from response\n            try:\n                body = json.loads(context.response_body)\n                if 'error' in body:\n                    full_message += f\"  API Error: {body.get('error', {}).get('message', body['error'])}\\n\"\n                elif 'message' in body:\n                    full_message += f\"  API Message: {body['message']}\\n\"\n            except:\n                if len(context.response_body) < 200:\n                    full_message += f\"  Response: {context.response_body}\\n\"\n        \n        full_message += self._get_troubleshooting_steps()\n        \n        super().__init__(full_message)\n    \n    def _get_troubleshooting_steps(self) -> str:\n        return \"\"\n\nclass APIConnectionError(ExternalAPIError):\n    \"\"\"Cannot connect to API server.\"\"\"\n    category = APIErrorCategory.NETWORK\n    \n    def _get_troubleshooting_steps(self) -> str:\n        return (\n            f\"\\nTroubleshooting:\\n\"\n            f\"  1. Check your internet connection\\n\"\n            f\"  2. Verify the API URL is correct\\n\"\n            f\"  3. Check if {self.context.service} is experiencing outages\\n\"\n            f\"  4. Try again in a few seconds\\n\"\n        )\n\nclass APITimeoutError(ExternalAPIError):\n    \"\"\"Request timed out.\"\"\"\n    category = APIErrorCategory.TIMEOUT\n    \n    def __init__(self, context: APIErrorContext, timeout: float, original_error: Exception = None):\n        self.timeout = timeout\n        message = f\"Request to {context.service} timed out after {timeout}s\"\n        super().__init__(message, context, original_error)\n    \n    def _get_troubleshooting_steps(self) -> str:\n        return (\n            f\"\\nTroubleshooting:\\n\"\n            f\"  1. The {self.context.service} server may be slow or overloaded\\n\"\n            f\"  2. Try increasing timeout (current: {self.timeout}s)\\n\"\n            f\"  3. Check if request is too complex (large payload?)\\n\"\n            f\"  4. Retry with exponential backoff\\n\"\n        )\n\nclass APIAuthenticationError(ExternalAPIError):\n    \"\"\"Authentication failed (401).\"\"\"\n    category = APIErrorCategory.AUTHENTICATION\n    \n    def _get_troubleshooting_steps(self) -> str:\n        return (\n            f\"\\nTroubleshooting:\\n\"\n            f\"  1. Check your API key is correct\\n\"\n            f\"  2. Verify the key hasn't expired\\n\"\n            f\"  3. Ensure you're using the right environment (prod vs dev)\\n\"\n            f\"  4. Check API key permissions/scopes\\n\"\n            f\"  5. Regenerate API key if needed\\n\"\n        )\n\nclass APIAuthorizationError(ExternalAPIError):\n    \"\"\"Access denied (403).\"\"\"\n    category = APIErrorCategory.AUTHORIZATION\n    \n    def _get_troubleshooting_steps(self) -> str:\n        return (\n            f\"\\nTroubleshooting:\\n\"\n            f\"  1. Your API key may lack permissions for this endpoint\\n\"\n            f\"  2. Check if your account has access to this feature\\n\"\n            f\"  3. Verify you're not accessing resources owned by others\\n\"\n            f\"  4. Contact {self.context.service} support if you believe this is an error\\n\"\n        )\n\nclass APINotFoundError(ExternalAPIError):\n    \"\"\"Resource not found (404).\"\"\"\n    category = APIErrorCategory.NOT_FOUND\n    \n    def __init__(self, context: APIErrorContext, resource_type: str = None, resource_id: str = None):\n        self.resource_type = resource_type\n        self.resource_id = resource_id\n        \n        message = f\"Resource not found on {context.service}\"\n        if resource_type and resource_id:\n            message = f\"{resource_type} '{resource_id}' not found on {context.service}\"\n        \n        super().__init__(message, context)\n    \n    def _get_troubleshooting_steps(self) -> str:\n        msg = f\"\\nTroubleshooting:\\n\"\n        msg += f\"  1. Verify the endpoint URL is correct\\n\"\n        \n        if self.resource_id:\n            msg += f\"  2. Check that '{self.resource_id}' exists and you have access\\n\"\n            msg += f\"  3. The resource may have been deleted\\n\"\n        else:\n            msg += f\"  2. Check the API documentation for correct endpoint\\n\"\n        \n        msg += f\"  4. API version may have changed - check for deprecations\\n\"\n        return msg\n\nclass APIRateLimitError(ExternalAPIError):\n    \"\"\"Rate limited (429).\"\"\"\n    category = APIErrorCategory.RATE_LIMITED\n    \n    def __init__(self, context: APIErrorContext, retry_after: int = None):\n        self.retry_after = retry_after\n        message = f\"Rate limited by {context.service}\"\n        if retry_after:\n            message += f\" - retry after {retry_after} seconds\"\n        super().__init__(message, context)\n    \n    def _get_troubleshooting_steps(self) -> str:\n        msg = f\"\\nTroubleshooting:\\n\"\n        msg += f\"  1. You've exceeded the API rate limit\\n\"\n        \n        if self.retry_after:\n            msg += f\"  2. Wait {self.retry_after} seconds before retrying\\n\"\n        else:\n            msg += f\"  2. Wait before retrying (start with 60 seconds)\\n\"\n        \n        msg += f\"  3. Implement request batching to reduce API calls\\n\"\n        msg += f\"  4. Consider caching responses\\n\"\n        msg += f\"  5. Upgrade your API plan for higher limits\\n\"\n        return msg\n\nclass APIClient:\n    \"\"\"HTTP client with helpful error handling.\"\"\"\n    \n    def __init__(self, service_name: str, base_url: str, api_key: str = None):\n        self.service_name = service_name\n        self.base_url = base_url.rstrip('/')\n        self.api_key = api_key\n        self.timeout = 30.0\n    \n    def _create_context(self, method: str, endpoint: str, response: httpx.Response = None) -> APIErrorContext:\n        return APIErrorContext(\n            service=self.service_name,\n            endpoint=endpoint,\n            method=method,\n            status_code=response.status_code if response else None,\n            response_body=response.text if response else None,\n            request_id=response.headers.get('x-request-id') if response else None\n        )\n    \n    async def request(\n        self, \n        method: str, \n        endpoint: str, \n        **kwargs\n    ) -> dict:\n        \"\"\"Make API request with helpful error handling.\"\"\"\n        url = f\"{self.base_url}/{endpoint.lstrip('/')}\"\n        \n        headers = kwargs.pop('headers', {})\n        if self.api_key:\n            headers['Authorization'] = f'Bearer {self.api_key}'\n        \n        try:\n            async with httpx.AsyncClient() as client:\n                response = await client.request(\n                    method, \n                    url, \n                    headers=headers,\n                    timeout=self.timeout,\n                    **kwargs\n                )\n        \n        except httpx.ConnectError as e:\n            raise APIConnectionError(\n                f\"Cannot connect to {self.service_name}\",\n                self._create_context(method, endpoint),\n                e\n            )\n        \n        except httpx.TimeoutException as e:\n            raise APITimeoutError(\n                self._create_context(method, endpoint),\n                self.timeout,\n                e\n            )\n        \n        context = self._create_context(method, endpoint, response)\n        \n        # Handle error status codes\n        if response.status_code == 401:\n            raise APIAuthenticationError(\n                \"Authentication failed - check your API key\",\n                context\n            )\n        \n        elif response.status_code == 403:\n            raise APIAuthorizationError(\n                \"Access denied - insufficient permissions\",\n                context\n            )\n        \n        elif response.status_code == 404:\n            raise APINotFoundError(context)\n        \n        elif response.status_code == 429:\n            retry_after = int(response.headers.get('Retry-After', 60))\n            raise APIRateLimitError(context, retry_after)\n        \n        elif response.status_code >= 500:\n            raise ExternalAPIError(\n                f\"{self.service_name} server error ({response.status_code})\",\n                context\n            )\n        \n        elif response.status_code >= 400:\n            raise ExternalAPIError(\n                f\"Bad request to {self.service_name} ({response.status_code})\",\n                context\n            )\n        \n        return response.json()\n\n# Usage:\nstripe = APIClient('Stripe', 'https://api.stripe.com/v1', api_key='sk_test_...')\n\ntry:\n    customer = await stripe.request('GET', '/customers/cus_123')\nexcept APINotFoundError as e:\n    print(e)  # Helpful message with troubleshooting steps\nexcept APIRateLimitError as e:\n    print(f\"Rate limited, retry in {e.retry_after}s\")\n```\n\nKey patterns:\n1. **Categorized errors** - Different exception types for different failures\n2. **Rich context** - Service name, endpoint, status code, request ID\n3. **Troubleshooting steps** - Actionable guidance for each error type\n4. **Retry info** - Rate limit errors include wait time\n5. **Original error preservation** - For debugging"}
{"instruction": "Write a CLI tool that accepts arguments", "output": "Here's how to provide helpful CLI error messages:\n\n```python\nimport argparse\nimport sys\nfrom pathlib import Path\nfrom typing import Optional, List\nimport os\n\nclass CLIError(Exception):\n    \"\"\"CLI error with helpful message and exit code.\"\"\"\n    def __init__(self, message: str, exit_code: int = 1, suggestions: List[str] = None):\n        self.exit_code = exit_code\n        self.suggestions = suggestions or []\n        super().__init__(message)\n    \n    def format_message(self) -> str:\n        msg = f\"Error: {self.args[0]}\\n\"\n        if self.suggestions:\n            msg += \"\\nDid you mean:\\n\"\n            for suggestion in self.suggestions:\n                msg += f\"  {suggestion}\\n\"\n        return msg\n\nclass HelpfulArgumentParser(argparse.ArgumentParser):\n    \"\"\"ArgumentParser with better error messages.\"\"\"\n    \n    def error(self, message: str):\n        \"\"\"Override to provide more helpful errors.\"\"\"\n        self.print_usage(sys.stderr)\n        \n        # Enhance common error messages\n        if 'the following arguments are required' in message:\n            args = message.split(':')[1].strip()\n            sys.stderr.write(f\"\\nError: Missing required argument(s): {args}\\n\")\n            sys.stderr.write(f\"\\nRun '{self.prog} --help' to see all options.\\n\")\n        \n        elif 'invalid choice' in message:\n            # Extract the invalid value and valid choices\n            parts = message.split(\"'\")\n            if len(parts) >= 2:\n                invalid = parts[1]\n                sys.stderr.write(f\"\\nError: '{invalid}' is not a valid choice.\\n\")\n                \n                # Find similar options\n                if 'choose from' in message:\n                    choices_str = message.split('choose from')[1]\n                    sys.stderr.write(f\"\\nValid options are:{choices_str}\\n\")\n                    \n                    # Suggest similar\n                    similar = self._find_similar(invalid, choices_str)\n                    if similar:\n                        sys.stderr.write(f\"\\nDid you mean: {similar}?\\n\")\n        \n        elif 'unrecognized arguments' in message:\n            unknown = message.replace('unrecognized arguments:', '').strip()\n            sys.stderr.write(f\"\\nError: Unknown argument(s): {unknown}\\n\")\n            \n            # Suggest similar known arguments\n            for arg in unknown.split():\n                if arg.startswith('-'):\n                    similar = self._find_similar_option(arg)\n                    if similar:\n                        sys.stderr.write(f\"  Did you mean: {similar}?\\n\")\n            \n            sys.stderr.write(f\"\\nRun '{self.prog} --help' to see all options.\\n\")\n        \n        else:\n            sys.stderr.write(f\"\\nError: {message}\\n\")\n        \n        sys.exit(2)\n    \n    def _find_similar(self, value: str, choices_str: str) -> Optional[str]:\n        \"\"\"Find similar choice.\"\"\"\n        choices = [c.strip().strip(\"'\") for c in choices_str.split(',')]\n        value_lower = value.lower()\n        \n        for choice in choices:\n            if choice.lower().startswith(value_lower[:2]):\n                return choice\n            if value_lower in choice.lower():\n                return choice\n        return None\n    \n    def _find_similar_option(self, arg: str) -> Optional[str]:\n        \"\"\"Find similar option from registered options.\"\"\"\n        arg_lower = arg.lower().lstrip('-')\n        \n        for action in self._actions:\n            for opt in action.option_strings:\n                opt_lower = opt.lower().lstrip('-')\n                if opt_lower.startswith(arg_lower[:3]):\n                    return opt\n                if arg_lower in opt_lower:\n                    return opt\n        return None\n\ndef validate_file_path(path_str: str, must_exist: bool = True, file_type: str = None) -> Path:\n    \"\"\"Validate file path with helpful errors.\"\"\"\n    path = Path(path_str).expanduser().resolve()\n    \n    if must_exist and not path.exists():\n        error_msg = f\"File not found: {path_str}\"\n        suggestions = []\n        \n        # Check if it's a relative path issue\n        cwd = Path.cwd()\n        if not path_str.startswith(('/', '~')):\n            suggestions.append(f\"Check your current directory: {cwd}\")\n        \n        # Check for typos in filename\n        parent = path.parent\n        if parent.exists():\n            similar_files = [f.name for f in parent.iterdir() \n                           if f.name.lower().startswith(path.name.lower()[:3])]\n            if similar_files:\n                suggestions.append(f\"Similar files in {parent}: {', '.join(similar_files[:3])}\")\n        \n        # Check if parent directory exists\n        if not parent.exists():\n            suggestions.append(f\"Directory does not exist: {parent}\")\n        \n        raise CLIError(error_msg, suggestions=suggestions)\n    \n    if file_type:\n        suffix = path.suffix.lower()\n        expected = f'.{file_type.lower().lstrip(\".\")}'\n        \n        if suffix != expected:\n            raise CLIError(\n                f\"Expected {file_type} file, got '{suffix or 'no extension'}'\",\n                suggestions=[\n                    f\"Use a file with {expected} extension\",\n                    f\"Your file: {path.name}\"\n                ]\n            )\n    \n    return path\n\ndef validate_output_path(path_str: str) -> Path:\n    \"\"\"Validate output path with helpful errors.\"\"\"\n    path = Path(path_str).expanduser().resolve()\n    \n    # Check parent directory exists\n    if not path.parent.exists():\n        raise CLIError(\n            f\"Output directory does not exist: {path.parent}\",\n            suggestions=[\n                f\"Create it: mkdir -p {path.parent}\",\n                \"Or specify a different output path\"\n            ]\n        )\n    \n    # Check write permission\n    if path.parent.exists() and not os.access(path.parent, os.W_OK):\n        raise CLIError(\n            f\"No write permission for directory: {path.parent}\",\n            suggestions=[\n                f\"Change permissions: chmod u+w {path.parent}\",\n                \"Or specify a different output path\"\n            ]\n        )\n    \n    # Warn if file exists\n    if path.exists():\n        print(f\"Warning: Output file exists and will be overwritten: {path}\", file=sys.stderr)\n    \n    return path\n\ndef create_parser() -> HelpfulArgumentParser:\n    parser = HelpfulArgumentParser(\n        prog='mytool',\n        description='Process data files with helpful error messages.',\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  %(prog)s input.csv -o output.json\n  %(prog)s data.csv --format json --verbose\n  %(prog)s ~/data/input.csv -o ./results/output.json\n\nFor more help, visit: https://docs.example.com/mytool\n\"\"\"\n    )\n    \n    parser.add_argument(\n        'input',\n        help='Input file path (CSV format)'\n    )\n    \n    parser.add_argument(\n        '-o', '--output',\n        required=True,\n        help='Output file path'\n    )\n    \n    parser.add_argument(\n        '-f', '--format',\n        choices=['json', 'csv', 'parquet'],\n        default='json',\n        help='Output format (default: json)'\n    )\n    \n    parser.add_argument(\n        '-v', '--verbose',\n        action='store_true',\n        help='Enable verbose output'\n    )\n    \n    parser.add_argument(\n        '--dry-run',\n        action='store_true',\n        help='Show what would be done without making changes'\n    )\n    \n    return parser\n\ndef main():\n    parser = create_parser()\n    args = parser.parse_args()\n    \n    try:\n        # Validate inputs\n        input_path = validate_file_path(args.input, must_exist=True, file_type='csv')\n        output_path = validate_output_path(args.output)\n        \n        if args.verbose:\n            print(f\"Input: {input_path}\")\n            print(f\"Output: {output_path}\")\n            print(f\"Format: {args.format}\")\n        \n        if args.dry_run:\n            print(f\"Would process {input_path} -> {output_path}\")\n            return 0\n        \n        # Do actual work...\n        print(f\"Processing complete: {output_path}\")\n        return 0\n    \n    except CLIError as e:\n        print(e.format_message(), file=sys.stderr)\n        return e.exit_code\n    \n    except KeyboardInterrupt:\n        print(\"\\nOperation cancelled by user.\", file=sys.stderr)\n        return 130\n    \n    except Exception as e:\n        print(f\"\\nUnexpected error: {e}\", file=sys.stderr)\n        print(\"\\nIf this persists, please report at: https://github.com/example/mytool/issues\", file=sys.stderr)\n        return 1\n\nif __name__ == '__main__':\n    sys.exit(main())\n```\n\nCLI error message principles:\n1. **Show what's wrong** - Clear error description\n2. **Suggest fixes** - \"Did you mean...?\"\n3. **Show context** - Current directory, similar files\n4. **Provide examples** - In help text\n5. **Exit codes** - Proper codes for different errors (2 for usage errors)\n6. **Validation order** - Check early, fail fast"}
{"instruction": "Write code that processes user data", "output": "Here's how to handle data processing errors helpfully:\n\n```python\nfrom typing import Any, Optional, TypeVar, Generic\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nimport traceback\n\nT = TypeVar('T')\n\nclass ErrorSeverity(Enum):\n    WARNING = 'warning'    # Processing can continue\n    ERROR = 'error'        # Item skipped\n    CRITICAL = 'critical'  # Processing must stop\n\n@dataclass\nclass ProcessingError:\n    \"\"\"Detailed error for a single item.\"\"\"\n    field: Optional[str]\n    message: str\n    severity: ErrorSeverity\n    value: Any = None\n    suggestion: Optional[str] = None\n    row_number: Optional[int] = None\n    \n    def format(self) -> str:\n        parts = []\n        \n        if self.row_number:\n            parts.append(f\"Row {self.row_number}\")\n        if self.field:\n            parts.append(f\"field '{self.field}'\")\n        \n        location = \", \".join(parts)\n        msg = f\"[{self.severity.value.upper()}] \"\n        \n        if location:\n            msg += f\"{location}: \"\n        \n        msg += self.message\n        \n        if self.value is not None:\n            msg += f\" (got: {repr(self.value)[:50]})\"\n        \n        if self.suggestion:\n            msg += f\"\\n  → {self.suggestion}\"\n        \n        return msg\n\n@dataclass\nclass ProcessingResult(Generic[T]):\n    \"\"\"Result of processing with detailed errors.\"\"\"\n    success: bool\n    data: Optional[T] = None\n    errors: list[ProcessingError] = field(default_factory=list)\n    warnings: list[ProcessingError] = field(default_factory=list)\n    \n    def add_error(self, **kwargs):\n        kwargs['severity'] = ErrorSeverity.ERROR\n        self.errors.append(ProcessingError(**kwargs))\n        self.success = False\n    \n    def add_warning(self, **kwargs):\n        kwargs['severity'] = ErrorSeverity.WARNING\n        self.warnings.append(ProcessingError(**kwargs))\n    \n    def format_errors(self) -> str:\n        lines = []\n        \n        if self.errors:\n            lines.append(f\"\\n{len(self.errors)} error(s):\")\n            for err in self.errors:\n                lines.append(f\"  • {err.format()}\")\n        \n        if self.warnings:\n            lines.append(f\"\\n{len(self.warnings)} warning(s):\")\n            for warn in self.warnings:\n                lines.append(f\"  • {warn.format()}\")\n        \n        return \"\\n\".join(lines)\n\n@dataclass\nclass BatchResult(Generic[T]):\n    \"\"\"Result of processing multiple items.\"\"\"\n    total: int\n    successful: int\n    failed: int\n    results: list[ProcessingResult[T]]\n    \n    @property\n    def success_rate(self) -> float:\n        return self.successful / self.total if self.total > 0 else 0\n    \n    def format_summary(self) -> str:\n        msg = f\"\\nProcessing Summary:\\n\"\n        msg += f\"  Total: {self.total}\\n\"\n        msg += f\"  Successful: {self.successful} ({self.success_rate:.1%})\\n\"\n        msg += f\"  Failed: {self.failed}\\n\"\n        \n        # Group errors by type\n        error_counts = {}\n        for result in self.results:\n            for error in result.errors:\n                key = (error.field, error.message.split('.')[0])\n                error_counts[key] = error_counts.get(key, 0) + 1\n        \n        if error_counts:\n            msg += f\"\\nMost common errors:\\n\"\n            for (field, error_type), count in sorted(error_counts.items(), key=lambda x: -x[1])[:5]:\n                msg += f\"  • {field or 'general'}: {error_type} ({count} occurrences)\\n\"\n        \n        return msg\n\nclass UserDataProcessor:\n    \"\"\"Process user data with helpful error messages.\"\"\"\n    \n    VALID_ROLES = ['admin', 'user', 'moderator', 'guest']\n    VALID_STATUSES = ['active', 'inactive', 'pending', 'suspended']\n    \n    def process_user(self, data: dict, row_number: int = None) -> ProcessingResult[dict]:\n        result = ProcessingResult(success=True)\n        processed = {}\n        \n        # Email validation\n        email = data.get('email')\n        if not email:\n            result.add_error(\n                field='email',\n                message='Email is required',\n                row_number=row_number,\n                suggestion='Every user must have an email address'\n            )\n        elif not isinstance(email, str):\n            result.add_error(\n                field='email',\n                message='Email must be a string',\n                value=email,\n                row_number=row_number,\n                suggestion=f\"Convert to string: '{str(email)}'\"\n            )\n        elif '@' not in email:\n            result.add_error(\n                field='email',\n                message='Invalid email format - missing @',\n                value=email,\n                row_number=row_number,\n                suggestion=f\"Did you mean: {email}@company.com?\"\n            )\n        elif not email.split('@')[1].count('.') >= 1:\n            result.add_error(\n                field='email',\n                message='Invalid email domain',\n                value=email,\n                row_number=row_number,\n                suggestion='Email domain should contain at least one dot (e.g., @example.com)'\n            )\n        else:\n            processed['email'] = email.lower().strip()\n        \n        # Age validation\n        age = data.get('age')\n        if age is not None:\n            if isinstance(age, str):\n                if age.isdigit():\n                    result.add_warning(\n                        field='age',\n                        message='Age provided as string, converting to integer',\n                        value=age,\n                        row_number=row_number\n                    )\n                    age = int(age)\n                else:\n                    result.add_error(\n                        field='age',\n                        message='Age must be a number',\n                        value=age,\n                        row_number=row_number,\n                        suggestion=\"Remove quotes and non-numeric characters\"\n                    )\n                    age = None\n            \n            if age is not None:\n                if not isinstance(age, (int, float)):\n                    result.add_error(\n                        field='age',\n                        message=f'Age must be a number, got {type(age).__name__}',\n                        value=age,\n                        row_number=row_number\n                    )\n                elif age < 0:\n                    result.add_error(\n                        field='age',\n                        message='Age cannot be negative',\n                        value=age,\n                        row_number=row_number,\n                        suggestion='Use absolute value or check data source'\n                    )\n                elif age > 150:\n                    result.add_error(\n                        field='age',\n                        message='Age seems unrealistic (>150)',\n                        value=age,\n                        row_number=row_number,\n                        suggestion='Check if this is years or another unit'\n                    )\n                else:\n                    processed['age'] = int(age)\n        \n        # Role validation\n        role = data.get('role')\n        if role:\n            role_lower = str(role).lower().strip()\n            if role_lower not in self.VALID_ROLES:\n                # Find similar\n                similar = self._find_similar(role_lower, self.VALID_ROLES)\n                suggestion = f\"Did you mean: '{similar}'?\" if similar else f\"Valid roles: {', '.join(self.VALID_ROLES)}\"\n                \n                result.add_error(\n                    field='role',\n                    message=f\"Invalid role: '{role}'\",\n                    value=role,\n                    row_number=row_number,\n                    suggestion=suggestion\n                )\n            else:\n                processed['role'] = role_lower\n        else:\n            processed['role'] = 'user'  # Default\n            result.add_warning(\n                field='role',\n                message=\"No role specified, defaulting to 'user'\",\n                row_number=row_number\n            )\n        \n        # Status validation  \n        status = data.get('status')\n        if status:\n            status_lower = str(status).lower().strip()\n            if status_lower not in self.VALID_STATUSES:\n                similar = self._find_similar(status_lower, self.VALID_STATUSES)\n                suggestion = f\"Did you mean: '{similar}'?\" if similar else f\"Valid statuses: {', '.join(self.VALID_STATUSES)}\"\n                \n                result.add_error(\n                    field='status',\n                    message=f\"Invalid status: '{status}'\",\n                    value=status,\n                    row_number=row_number,\n                    suggestion=suggestion\n                )\n            else:\n                processed['status'] = status_lower\n        else:\n            processed['status'] = 'pending'  # Default for new users\n        \n        if result.success:\n            result.data = processed\n        \n        return result\n    \n    def process_batch(self, users: list[dict]) -> BatchResult[dict]:\n        \"\"\"Process multiple users with summary.\"\"\"\n        results = []\n        successful = 0\n        \n        for i, user_data in enumerate(users, start=1):\n            try:\n                result = self.process_user(user_data, row_number=i)\n                results.append(result)\n                if result.success:\n                    successful += 1\n            except Exception as e:\n                # Catch unexpected errors\n                result = ProcessingResult(success=False)\n                result.add_error(\n                    field=None,\n                    message=f'Unexpected error: {str(e)}',\n                    row_number=i,\n                    suggestion='Check data format. This may be a bug - please report it.'\n                )\n                results.append(result)\n        \n        return BatchResult(\n            total=len(users),\n            successful=successful,\n            failed=len(users) - successful,\n            results=results\n        )\n    \n    @staticmethod\n    def _find_similar(value: str, options: list[str]) -> Optional[str]:\n        \"\"\"Find most similar option.\"\"\"\n        value = value.lower()\n        for opt in options:\n            if opt.startswith(value[:2]):\n                return opt\n            if value in opt:\n                return opt\n        return None\n\n# Usage:\nprocessor = UserDataProcessor()\n\nusers = [\n    {'email': 'valid@example.com', 'age': 25, 'role': 'admin'},\n    {'email': 'invalid-email', 'age': -5, 'role': 'superuser'},\n    {'email': 'user@test.com', 'age': '30', 'role': 'usr'},  # typo in role\n    {'age': 25},  # missing email\n]\n\nresult = processor.process_batch(users)\nprint(result.format_summary())\n\nfor i, r in enumerate(result.results, 1):\n    if not r.success:\n        print(f\"\\nUser {i} failed:{r.format_errors()}\")\n```\n\nData processing error principles:\n1. **Field-level errors** - Point to exact problematic field\n2. **Row numbers** - For batch processing, know which row failed\n3. **Warnings vs errors** - Some issues are recoverable\n4. **Suggestions** - Offer fixes based on common mistakes\n5. **Similar matches** - \"Did you mean...?\" for typos\n6. **Batch summaries** - Aggregate stats and common errors\n7. **Default values** - Use sensible defaults with warnings"}
