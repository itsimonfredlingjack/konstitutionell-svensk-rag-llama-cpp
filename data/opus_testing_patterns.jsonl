{"instruction": "Write tests for a user authentication function", "output": "Here's how to properly test authentication:\n\n```python\nimport pytest\nfrom unittest.mock import Mock, patch, AsyncMock\nfrom datetime import datetime, timedelta\nimport jwt\n\nfrom app.auth import (\n    authenticate_user,\n    create_access_token,\n    verify_token,\n    hash_password,\n    verify_password,\n    AuthenticationError,\n    TokenExpiredError,\n)\nfrom app.models import User\n\n\nclass TestPasswordHashing:\n    \"\"\"Test password hashing functions.\"\"\"\n    \n    def test_hash_password_returns_different_hash(self):\n        \"\"\"Same password should produce different hashes (due to salt).\"\"\"\n        password = \"SecurePass123\"\n        hash1 = hash_password(password)\n        hash2 = hash_password(password)\n        \n        assert hash1 != hash2\n        assert hash1 != password  # Not stored in plain text\n    \n    def test_verify_password_correct(self):\n        \"\"\"Correct password should verify.\"\"\"\n        password = \"SecurePass123\"\n        hashed = hash_password(password)\n        \n        assert verify_password(password, hashed) is True\n    \n    def test_verify_password_incorrect(self):\n        \"\"\"Wrong password should not verify.\"\"\"\n        hashed = hash_password(\"SecurePass123\")\n        \n        assert verify_password(\"WrongPassword\", hashed) is False\n    \n    def test_verify_password_empty(self):\n        \"\"\"Empty password should not verify.\"\"\"\n        hashed = hash_password(\"SecurePass123\")\n        \n        assert verify_password(\"\", hashed) is False\n    \n    @pytest.mark.parametrize(\"password\", [\n        \"short\",\n        \"no_uppercase123\",\n        \"NO_LOWERCASE123\",\n        \"NoNumbers\",\n    ])\n    def test_hash_password_weak_passwords(self, password):\n        \"\"\"Weak passwords should still hash (validation elsewhere).\"\"\"\n        # Hashing doesn't validate - that's the validator's job\n        hashed = hash_password(password)\n        assert hashed is not None\n        assert verify_password(password, hashed)\n\n\nclass TestTokenCreation:\n    \"\"\"Test JWT token creation.\"\"\"\n    \n    def test_create_token_contains_user_id(self):\n        \"\"\"Token should contain user_id in payload.\"\"\"\n        token = create_access_token(user_id=123)\n        payload = jwt.decode(token, options={\"verify_signature\": False})\n        \n        assert payload[\"sub\"] == \"123\"\n    \n    def test_create_token_has_expiration(self):\n        \"\"\"Token should have expiration time.\"\"\"\n        token = create_access_token(user_id=123)\n        payload = jwt.decode(token, options={\"verify_signature\": False})\n        \n        assert \"exp\" in payload\n        exp_time = datetime.fromtimestamp(payload[\"exp\"])\n        assert exp_time > datetime.utcnow()\n    \n    def test_create_token_custom_expiration(self):\n        \"\"\"Custom expiration should be respected.\"\"\"\n        token = create_access_token(user_id=123, expires_delta=timedelta(hours=1))\n        payload = jwt.decode(token, options={\"verify_signature\": False})\n        \n        exp_time = datetime.fromtimestamp(payload[\"exp\"])\n        expected = datetime.utcnow() + timedelta(hours=1)\n        \n        # Allow 5 second tolerance\n        assert abs((exp_time - expected).total_seconds()) < 5\n    \n    def test_create_token_with_extra_data(self):\n        \"\"\"Extra data should be included in payload.\"\"\"\n        token = create_access_token(\n            user_id=123,\n            extra_data={\"role\": \"admin\", \"permissions\": [\"read\", \"write\"]}\n        )\n        payload = jwt.decode(token, options={\"verify_signature\": False})\n        \n        assert payload[\"role\"] == \"admin\"\n        assert payload[\"permissions\"] == [\"read\", \"write\"]\n\n\nclass TestTokenVerification:\n    \"\"\"Test JWT token verification.\"\"\"\n    \n    def test_verify_valid_token(self):\n        \"\"\"Valid token should return payload.\"\"\"\n        token = create_access_token(user_id=123)\n        payload = verify_token(token)\n        \n        assert payload[\"sub\"] == \"123\"\n    \n    def test_verify_expired_token(self):\n        \"\"\"Expired token should raise TokenExpiredError.\"\"\"\n        token = create_access_token(\n            user_id=123,\n            expires_delta=timedelta(seconds=-1)  # Already expired\n        )\n        \n        with pytest.raises(TokenExpiredError) as exc_info:\n            verify_token(token)\n        \n        assert \"expired\" in str(exc_info.value).lower()\n    \n    def test_verify_invalid_token(self):\n        \"\"\"Invalid token should raise AuthenticationError.\"\"\"\n        with pytest.raises(AuthenticationError):\n            verify_token(\"invalid.token.here\")\n    \n    def test_verify_tampered_token(self):\n        \"\"\"Tampered token should fail verification.\"\"\"\n        token = create_access_token(user_id=123)\n        # Tamper with the token\n        parts = token.split(\".\")\n        parts[1] = parts[1][:-5] + \"XXXXX\"  # Modify payload\n        tampered = \".\".join(parts)\n        \n        with pytest.raises(AuthenticationError):\n            verify_token(tampered)\n\n\nclass TestUserAuthentication:\n    \"\"\"Test full authentication flow.\"\"\"\n    \n    @pytest.fixture\n    def mock_user(self):\n        \"\"\"Create a mock user for testing.\"\"\"\n        return User(\n            id=1,\n            email=\"test@example.com\",\n            hashed_password=hash_password(\"CorrectPassword123\"),\n            is_active=True\n        )\n    \n    @pytest.fixture\n    def mock_db(self, mock_user):\n        \"\"\"Mock database session.\"\"\"\n        db = Mock()\n        db.query.return_value.filter.return_value.first.return_value = mock_user\n        return db\n    \n    @pytest.mark.asyncio\n    async def test_authenticate_success(self, mock_db, mock_user):\n        \"\"\"Valid credentials should return user and token.\"\"\"\n        result = await authenticate_user(\n            db=mock_db,\n            email=\"test@example.com\",\n            password=\"CorrectPassword123\"\n        )\n        \n        assert result[\"user\"].id == mock_user.id\n        assert \"access_token\" in result\n        assert result[\"token_type\"] == \"bearer\"\n    \n    @pytest.mark.asyncio\n    async def test_authenticate_wrong_password(self, mock_db):\n        \"\"\"Wrong password should raise AuthenticationError.\"\"\"\n        with pytest.raises(AuthenticationError) as exc_info:\n            await authenticate_user(\n                db=mock_db,\n                email=\"test@example.com\",\n                password=\"WrongPassword\"\n            )\n        \n        assert \"Invalid credentials\" in str(exc_info.value)\n    \n    @pytest.mark.asyncio\n    async def test_authenticate_user_not_found(self, mock_db):\n        \"\"\"Non-existent user should raise AuthenticationError.\"\"\"\n        mock_db.query.return_value.filter.return_value.first.return_value = None\n        \n        with pytest.raises(AuthenticationError) as exc_info:\n            await authenticate_user(\n                db=mock_db,\n                email=\"nonexistent@example.com\",\n                password=\"AnyPassword\"\n            )\n        \n        # Should not reveal whether user exists\n        assert \"Invalid credentials\" in str(exc_info.value)\n    \n    @pytest.mark.asyncio\n    async def test_authenticate_inactive_user(self, mock_db, mock_user):\n        \"\"\"Inactive user should not be able to authenticate.\"\"\"\n        mock_user.is_active = False\n        \n        with pytest.raises(AuthenticationError) as exc_info:\n            await authenticate_user(\n                db=mock_db,\n                email=\"test@example.com\",\n                password=\"CorrectPassword123\"\n            )\n        \n        assert \"inactive\" in str(exc_info.value).lower()\n\n\nclass TestAuthenticationEdgeCases:\n    \"\"\"Test edge cases and security concerns.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_timing_attack_prevention(self, mock_db):\n        \"\"\"Auth should take similar time for existing vs non-existing users.\"\"\"\n        import time\n        \n        # Time for non-existent user\n        mock_db.query.return_value.filter.return_value.first.return_value = None\n        start = time.time()\n        try:\n            await authenticate_user(mock_db, \"fake@example.com\", \"pass\")\n        except AuthenticationError:\n            pass\n        time_no_user = time.time() - start\n        \n        # Time for wrong password\n        mock_user = User(id=1, email=\"real@example.com\", \n                        hashed_password=hash_password(\"real\"), is_active=True)\n        mock_db.query.return_value.filter.return_value.first.return_value = mock_user\n        start = time.time()\n        try:\n            await authenticate_user(mock_db, \"real@example.com\", \"wrong\")\n        except AuthenticationError:\n            pass\n        time_wrong_pass = time.time() - start\n        \n        # Times should be similar (within 100ms)\n        assert abs(time_no_user - time_wrong_pass) < 0.1\n    \n    def test_password_not_in_token(self):\n        \"\"\"Password should never appear in token.\"\"\"\n        token = create_access_token(user_id=123)\n        \n        # Decode without verification to inspect payload\n        payload = jwt.decode(token, options={\"verify_signature\": False})\n        payload_str = str(payload).lower()\n        \n        assert \"password\" not in payload_str\n        assert \"secret\" not in payload_str\n```\n\nKey testing patterns:\n1. **Organized test classes** - Group related tests\n2. **Descriptive names** - `test_verify_expired_token` not `test_token_2`\n3. **Fixtures** for shared setup\n4. **Parametrize** for testing multiple inputs\n5. **Edge cases** - Empty, invalid, tampered\n6. **Security tests** - Timing attacks, data leakage\n7. **Async test support** with pytest-asyncio"}
{"instruction": "Write tests for an API endpoint", "output": "Here's how to properly test FastAPI endpoints:\n\n```python\nimport pytest\nfrom httpx import AsyncClient, ASGITransport\nfrom unittest.mock import Mock, patch, AsyncMock\nfrom fastapi import status\nimport json\n\nfrom app.main import app\nfrom app.models import User, Item\nfrom app.database import get_db\n\n\n# Test fixtures\n@pytest.fixture\ndef mock_db():\n    \"\"\"Create mock database session.\"\"\"\n    db = Mock()\n    db.commit = Mock()\n    db.refresh = Mock()\n    db.add = Mock()\n    return db\n\n@pytest.fixture\ndef override_db(mock_db):\n    \"\"\"Override database dependency.\"\"\"\n    app.dependency_overrides[get_db] = lambda: mock_db\n    yield mock_db\n    app.dependency_overrides.clear()\n\n@pytest.fixture\nasync def client():\n    \"\"\"Async test client.\"\"\"\n    async with AsyncClient(\n        transport=ASGITransport(app=app),\n        base_url=\"http://test\"\n    ) as ac:\n        yield ac\n\n@pytest.fixture\ndef auth_headers():\n    \"\"\"Generate auth headers for protected endpoints.\"\"\"\n    from app.auth import create_access_token\n    token = create_access_token(user_id=1)\n    return {\"Authorization\": f\"Bearer {token}\"}\n\n\nclass TestCreateItem:\n    \"\"\"Test POST /items endpoint.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_create_item_success(self, client, override_db, auth_headers):\n        \"\"\"Valid request should create item.\"\"\"\n        payload = {\n            \"name\": \"Test Item\",\n            \"description\": \"A test item\",\n            \"price\": 29.99,\n            \"quantity\": 10\n        }\n        \n        response = await client.post(\n            \"/items\",\n            json=payload,\n            headers=auth_headers\n        )\n        \n        assert response.status_code == status.HTTP_201_CREATED\n        data = response.json()\n        assert data[\"name\"] == payload[\"name\"]\n        assert data[\"price\"] == payload[\"price\"]\n        assert \"id\" in data\n    \n    @pytest.mark.asyncio\n    async def test_create_item_missing_required_field(self, client, auth_headers):\n        \"\"\"Missing required field should return 422.\"\"\"\n        payload = {\n            \"description\": \"Missing name\",\n            \"price\": 29.99\n        }\n        \n        response = await client.post(\n            \"/items\",\n            json=payload,\n            headers=auth_headers\n        )\n        \n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n        data = response.json()\n        assert \"detail\" in data\n        # Check error mentions the missing field\n        error_fields = [e[\"loc\"][-1] for e in data[\"detail\"]]\n        assert \"name\" in error_fields\n    \n    @pytest.mark.asyncio\n    async def test_create_item_invalid_price(self, client, auth_headers):\n        \"\"\"Negative price should be rejected.\"\"\"\n        payload = {\n            \"name\": \"Test Item\",\n            \"price\": -10.00\n        }\n        \n        response = await client.post(\n            \"/items\",\n            json=payload,\n            headers=auth_headers\n        )\n        \n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n        assert \"price\" in response.text.lower()\n    \n    @pytest.mark.asyncio\n    async def test_create_item_unauthorized(self, client):\n        \"\"\"Request without auth should return 401.\"\"\"\n        payload = {\"name\": \"Test\", \"price\": 10.00}\n        \n        response = await client.post(\"/items\", json=payload)\n        \n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n    \n    @pytest.mark.asyncio\n    async def test_create_item_invalid_token(self, client):\n        \"\"\"Invalid token should return 401.\"\"\"\n        payload = {\"name\": \"Test\", \"price\": 10.00}\n        headers = {\"Authorization\": \"Bearer invalid_token\"}\n        \n        response = await client.post(\"/items\", json=payload, headers=headers)\n        \n        assert response.status_code == status.HTTP_401_UNAUTHORIZED\n\n\nclass TestGetItem:\n    \"\"\"Test GET /items/{id} endpoint.\"\"\"\n    \n    @pytest.fixture\n    def mock_item(self):\n        return Item(id=1, name=\"Test\", price=10.0, owner_id=1)\n    \n    @pytest.mark.asyncio\n    async def test_get_item_success(self, client, override_db, mock_item):\n        \"\"\"Existing item should be returned.\"\"\"\n        override_db.query.return_value.filter.return_value.first.return_value = mock_item\n        \n        response = await client.get(\"/items/1\")\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert data[\"id\"] == 1\n        assert data[\"name\"] == \"Test\"\n    \n    @pytest.mark.asyncio\n    async def test_get_item_not_found(self, client, override_db):\n        \"\"\"Non-existent item should return 404.\"\"\"\n        override_db.query.return_value.filter.return_value.first.return_value = None\n        \n        response = await client.get(\"/items/999\")\n        \n        assert response.status_code == status.HTTP_404_NOT_FOUND\n        assert \"not found\" in response.json()[\"detail\"].lower()\n    \n    @pytest.mark.asyncio\n    async def test_get_item_invalid_id(self, client):\n        \"\"\"Non-integer ID should return 422.\"\"\"\n        response = await client.get(\"/items/abc\")\n        \n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n\nclass TestListItems:\n    \"\"\"Test GET /items endpoint with pagination.\"\"\"\n    \n    @pytest.fixture\n    def mock_items(self):\n        return [\n            Item(id=i, name=f\"Item {i}\", price=10.0 * i, owner_id=1)\n            for i in range(1, 26)  # 25 items\n        ]\n    \n    @pytest.mark.asyncio\n    async def test_list_items_default_pagination(self, client, override_db, mock_items):\n        \"\"\"Default pagination should return first 20 items.\"\"\"\n        override_db.query.return_value.offset.return_value.limit.return_value.all.return_value = mock_items[:20]\n        override_db.query.return_value.count.return_value = 25\n        \n        response = await client.get(\"/items\")\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert len(data[\"items\"]) == 20\n        assert data[\"total\"] == 25\n        assert data[\"page\"] == 1\n    \n    @pytest.mark.asyncio\n    async def test_list_items_custom_pagination(self, client, override_db, mock_items):\n        \"\"\"Custom page size should be respected.\"\"\"\n        override_db.query.return_value.offset.return_value.limit.return_value.all.return_value = mock_items[:5]\n        override_db.query.return_value.count.return_value = 25\n        \n        response = await client.get(\"/items?page=1&size=5\")\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert len(data[\"items\"]) == 5\n    \n    @pytest.mark.asyncio\n    async def test_list_items_page_beyond_total(self, client, override_db):\n        \"\"\"Page beyond total should return empty list.\"\"\"\n        override_db.query.return_value.offset.return_value.limit.return_value.all.return_value = []\n        override_db.query.return_value.count.return_value = 25\n        \n        response = await client.get(\"/items?page=100\")\n        \n        assert response.status_code == status.HTTP_200_OK\n        data = response.json()\n        assert len(data[\"items\"]) == 0\n    \n    @pytest.mark.asyncio\n    @pytest.mark.parametrize(\"param,value\", [\n        (\"page\", 0),\n        (\"page\", -1),\n        (\"size\", 0),\n        (\"size\", 101),  # Assuming max is 100\n    ])\n    async def test_list_items_invalid_pagination(self, client, param, value):\n        \"\"\"Invalid pagination params should return 422.\"\"\"\n        response = await client.get(f\"/items?{param}={value}\")\n        \n        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY\n\n\nclass TestUpdateItem:\n    \"\"\"Test PUT /items/{id} endpoint.\"\"\"\n    \n    @pytest.fixture\n    def existing_item(self):\n        return Item(id=1, name=\"Original\", price=10.0, owner_id=1)\n    \n    @pytest.mark.asyncio\n    async def test_update_item_success(self, client, override_db, existing_item, auth_headers):\n        \"\"\"Valid update should succeed.\"\"\"\n        override_db.query.return_value.filter.return_value.first.return_value = existing_item\n        \n        response = await client.put(\n            \"/items/1\",\n            json={\"name\": \"Updated\", \"price\": 20.0},\n            headers=auth_headers\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        assert response.json()[\"name\"] == \"Updated\"\n    \n    @pytest.mark.asyncio\n    async def test_update_item_partial(self, client, override_db, existing_item, auth_headers):\n        \"\"\"Partial update should only change provided fields.\"\"\"\n        override_db.query.return_value.filter.return_value.first.return_value = existing_item\n        original_price = existing_item.price\n        \n        response = await client.put(\n            \"/items/1\",\n            json={\"name\": \"Updated\"},  # Only name, not price\n            headers=auth_headers\n        )\n        \n        assert response.status_code == status.HTTP_200_OK\n        # Price should remain unchanged\n        assert existing_item.price == original_price\n    \n    @pytest.mark.asyncio\n    async def test_update_item_not_owner(self, client, override_db, existing_item):\n        \"\"\"Non-owner should not be able to update.\"\"\"\n        existing_item.owner_id = 999  # Different owner\n        override_db.query.return_value.filter.return_value.first.return_value = existing_item\n        \n        # Auth headers for user_id=1, but item owned by 999\n        from app.auth import create_access_token\n        headers = {\"Authorization\": f\"Bearer {create_access_token(user_id=1)}\"}\n        \n        response = await client.put(\n            \"/items/1\",\n            json={\"name\": \"Hacked\"},\n            headers=headers\n        )\n        \n        assert response.status_code == status.HTTP_403_FORBIDDEN\n\n\nclass TestDeleteItem:\n    \"\"\"Test DELETE /items/{id} endpoint.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_delete_item_success(self, client, override_db, auth_headers):\n        \"\"\"Owner should be able to delete item.\"\"\"\n        mock_item = Item(id=1, name=\"ToDelete\", price=10.0, owner_id=1)\n        override_db.query.return_value.filter.return_value.first.return_value = mock_item\n        \n        response = await client.delete(\"/items/1\", headers=auth_headers)\n        \n        assert response.status_code == status.HTTP_204_NO_CONTENT\n        override_db.delete.assert_called_once_with(mock_item)\n        override_db.commit.assert_called_once()\n    \n    @pytest.mark.asyncio\n    async def test_delete_item_not_found(self, client, override_db, auth_headers):\n        \"\"\"Deleting non-existent item should return 404.\"\"\"\n        override_db.query.return_value.filter.return_value.first.return_value = None\n        \n        response = await client.delete(\"/items/999\", headers=auth_headers)\n        \n        assert response.status_code == status.HTTP_404_NOT_FOUND\n    \n    @pytest.mark.asyncio\n    async def test_delete_item_idempotent(self, client, override_db, auth_headers):\n        \"\"\"Multiple deletes should not cause errors.\"\"\"\n        override_db.query.return_value.filter.return_value.first.return_value = None\n        \n        # Second delete of same item\n        response = await client.delete(\"/items/1\", headers=auth_headers)\n        \n        # Should return 404, not 500\n        assert response.status_code == status.HTTP_404_NOT_FOUND\n```\n\nKey API testing patterns:\n1. **Async client** for FastAPI async endpoints\n2. **Dependency overrides** for database mocking\n3. **Auth fixtures** for protected endpoints\n4. **Status code assertions** with descriptive names\n5. **Parametrized tests** for validation edge cases\n6. **Authorization tests** - ownership, permissions\n7. **Idempotency tests** for DELETE operations"}
{"instruction": "Write tests for a data processing function", "output": "Here's how to test data processing with edge cases:\n\n```python\nimport pytest\nfrom unittest.mock import Mock, patch, mock_open\nfrom pathlib import Path\nimport json\nimport csv\nfrom io import StringIO\n\nfrom app.processors import (\n    DataProcessor,\n    ProcessingResult,\n    ValidationError,\n    TransformationError,\n)\n\n\nclass TestDataProcessor:\n    \"\"\"Test data processing functionality.\"\"\"\n    \n    @pytest.fixture\n    def processor(self):\n        return DataProcessor()\n    \n    @pytest.fixture\n    def sample_records(self):\n        return [\n            {\"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\", \"age\": 30},\n            {\"id\": 2, \"name\": \"Bob\", \"email\": \"bob@example.com\", \"age\": 25},\n            {\"id\": 3, \"name\": \"Charlie\", \"email\": \"charlie@example.com\", \"age\": 35},\n        ]\n    \n    # Basic functionality tests\n    \n    def test_process_valid_records(self, processor, sample_records):\n        \"\"\"Valid records should process successfully.\"\"\"\n        result = processor.process(sample_records)\n        \n        assert result.success is True\n        assert len(result.processed) == 3\n        assert result.failed_count == 0\n    \n    def test_process_empty_list(self, processor):\n        \"\"\"Empty input should return empty result, not error.\"\"\"\n        result = processor.process([])\n        \n        assert result.success is True\n        assert len(result.processed) == 0\n        assert result.failed_count == 0\n    \n    def test_process_single_record(self, processor):\n        \"\"\"Single record should work.\"\"\"\n        record = {\"id\": 1, \"name\": \"Test\", \"email\": \"test@example.com\"}\n        result = processor.process([record])\n        \n        assert result.success is True\n        assert len(result.processed) == 1\n    \n    # Validation tests\n    \n    def test_process_missing_required_field(self, processor):\n        \"\"\"Missing required field should cause record failure.\"\"\"\n        records = [\n            {\"id\": 1, \"email\": \"no-name@example.com\"},  # Missing 'name'\n        ]\n        \n        result = processor.process(records)\n        \n        assert result.success is False\n        assert result.failed_count == 1\n        assert \"name\" in result.errors[0].field\n    \n    def test_process_invalid_email(self, processor):\n        \"\"\"Invalid email should be flagged.\"\"\"\n        records = [\n            {\"id\": 1, \"name\": \"Test\", \"email\": \"not-an-email\"},\n        ]\n        \n        result = processor.process(records)\n        \n        assert result.failed_count == 1\n        assert \"email\" in result.errors[0].field.lower()\n    \n    @pytest.mark.parametrize(\"invalid_age\", [\n        -1,         # Negative\n        0,          # Zero\n        200,        # Unrealistic\n        \"thirty\",   # String\n        None,       # Null\n    ])\n    def test_process_invalid_age_values(self, processor, invalid_age):\n        \"\"\"Various invalid age values should be rejected.\"\"\"\n        records = [\n            {\"id\": 1, \"name\": \"Test\", \"email\": \"test@example.com\", \"age\": invalid_age},\n        ]\n        \n        result = processor.process(records)\n        \n        assert result.failed_count == 1 or result.warnings_count >= 1\n    \n    # Transformation tests\n    \n    def test_process_normalizes_email(self, processor):\n        \"\"\"Emails should be normalized to lowercase.\"\"\"\n        records = [\n            {\"id\": 1, \"name\": \"Test\", \"email\": \"TEST@EXAMPLE.COM\"},\n        ]\n        \n        result = processor.process(records)\n        \n        assert result.processed[0][\"email\"] == \"test@example.com\"\n    \n    def test_process_trims_whitespace(self, processor):\n        \"\"\"Leading/trailing whitespace should be trimmed.\"\"\"\n        records = [\n            {\"id\": 1, \"name\": \"  Test  \", \"email\": \" test@example.com \"},\n        ]\n        \n        result = processor.process(records)\n        \n        assert result.processed[0][\"name\"] == \"Test\"\n        assert result.processed[0][\"email\"] == \"test@example.com\"\n    \n    def test_process_adds_computed_fields(self, processor):\n        \"\"\"Computed fields should be added.\"\"\"\n        records = [\n            {\"id\": 1, \"name\": \"Test User\", \"email\": \"test@example.com\"},\n        ]\n        \n        result = processor.process(records)\n        \n        # Check computed fields exist\n        processed = result.processed[0]\n        assert \"processed_at\" in processed\n        assert \"name_length\" in processed\n    \n    # Partial failure tests\n    \n    def test_process_continues_after_invalid_record(self, processor):\n        \"\"\"Processing should continue after encountering invalid record.\"\"\"\n        records = [\n            {\"id\": 1, \"name\": \"Valid\", \"email\": \"valid@example.com\"},\n            {\"id\": 2, \"name\": \"\", \"email\": \"invalid\"},  # Invalid\n            {\"id\": 3, \"name\": \"Also Valid\", \"email\": \"also@example.com\"},\n        ]\n        \n        result = processor.process(records)\n        \n        assert len(result.processed) == 2  # Two valid records\n        assert result.failed_count == 1\n    \n    def test_process_reports_all_errors_in_record(self, processor):\n        \"\"\"Multiple errors in one record should all be reported.\"\"\"\n        records = [\n            {\"id\": \"not-int\", \"name\": \"\", \"email\": \"invalid\"},  # 3 errors\n        ]\n        \n        result = processor.process(records)\n        \n        # Should report all validation errors, not just first\n        assert len(result.errors) >= 2\n    \n    # Edge cases\n    \n    def test_process_duplicate_ids(self, processor):\n        \"\"\"Duplicate IDs should be detected.\"\"\"\n        records = [\n            {\"id\": 1, \"name\": \"First\", \"email\": \"first@example.com\"},\n            {\"id\": 1, \"name\": \"Duplicate\", \"email\": \"dup@example.com\"},\n        ]\n        \n        result = processor.process(records)\n        \n        # Either reject duplicate or warn\n        assert result.failed_count == 1 or result.warnings_count >= 1\n    \n    def test_process_unicode_characters(self, processor):\n        \"\"\"Unicode in names should be handled.\"\"\"\n        records = [\n            {\"id\": 1, \"name\": \"José García\", \"email\": \"jose@example.com\"},\n            {\"id\": 2, \"name\": \"田中太郎\", \"email\": \"tanaka@example.com\"},\n            {\"id\": 3, \"name\": \"Мария\", \"email\": \"maria@example.com\"},\n        ]\n        \n        result = processor.process(records)\n        \n        assert result.success is True\n        assert len(result.processed) == 3\n    \n    def test_process_very_long_values(self, processor):\n        \"\"\"Very long values should be handled (truncated or rejected).\"\"\"\n        records = [\n            {\"id\": 1, \"name\": \"A\" * 10000, \"email\": \"test@example.com\"},\n        ]\n        \n        result = processor.process(records)\n        \n        # Should either truncate or reject, not crash\n        if result.success:\n            assert len(result.processed[0][\"name\"]) <= 255  # Reasonable limit\n        else:\n            assert \"length\" in result.errors[0].message.lower()\n    \n    def test_process_special_characters(self, processor):\n        \"\"\"Special characters in fields should be handled safely.\"\"\"\n        records = [\n            {\"id\": 1, \"name\": \"O'Brien\", \"email\": \"obrien@example.com\"},\n            {\"id\": 2, \"name\": 'Test \"Quoted\"', \"email\": \"test@example.com\"},\n            {\"id\": 3, \"name\": \"Back\\\\slash\", \"email\": \"back@example.com\"},\n        ]\n        \n        result = processor.process(records)\n        \n        assert result.success is True\n    \n    # Performance / batch tests\n    \n    def test_process_large_batch(self, processor):\n        \"\"\"Large batch should process without memory issues.\"\"\"\n        records = [\n            {\"id\": i, \"name\": f\"User {i}\", \"email\": f\"user{i}@example.com\"}\n            for i in range(10000)\n        ]\n        \n        result = processor.process(records)\n        \n        assert result.success is True\n        assert len(result.processed) == 10000\n    \n    def test_process_with_progress_callback(self, processor):\n        \"\"\"Progress callback should be called.\"\"\"\n        records = [{\"id\": i, \"name\": f\"U{i}\", \"email\": f\"u{i}@e.com\"} for i in range(10)]\n        progress_calls = []\n        \n        def on_progress(current, total):\n            progress_calls.append((current, total))\n        \n        result = processor.process(records, on_progress=on_progress)\n        \n        assert len(progress_calls) > 0\n        assert progress_calls[-1] == (10, 10)  # Final call\n\n\nclass TestDataProcessorFileHandling:\n    \"\"\"Test file input/output for data processor.\"\"\"\n    \n    @pytest.fixture\n    def processor(self):\n        return DataProcessor()\n    \n    def test_load_from_csv(self, processor, tmp_path):\n        \"\"\"Should load data from CSV file.\"\"\"\n        csv_file = tmp_path / \"test.csv\"\n        csv_file.write_text(\"id,name,email\\n1,Test,test@example.com\\n\")\n        \n        records = processor.load_csv(csv_file)\n        \n        assert len(records) == 1\n        assert records[0][\"name\"] == \"Test\"\n    \n    def test_load_from_json(self, processor, tmp_path):\n        \"\"\"Should load data from JSON file.\"\"\"\n        json_file = tmp_path / \"test.json\"\n        json_file.write_text('[{\"id\": 1, \"name\": \"Test\", \"email\": \"test@example.com\"}]')\n        \n        records = processor.load_json(json_file)\n        \n        assert len(records) == 1\n    \n    def test_load_csv_with_encoding_issues(self, processor, tmp_path):\n        \"\"\"Should handle various file encodings.\"\"\"\n        csv_file = tmp_path / \"test.csv\"\n        csv_file.write_bytes(\"id,name,email\\n1,Tëst,test@example.com\\n\".encode('utf-8'))\n        \n        records = processor.load_csv(csv_file)\n        \n        assert records[0][\"name\"] == \"Tëst\"\n    \n    def test_load_nonexistent_file(self, processor):\n        \"\"\"Should raise clear error for missing file.\"\"\"\n        with pytest.raises(FileNotFoundError) as exc_info:\n            processor.load_csv(Path(\"/nonexistent/file.csv\"))\n        \n        assert \"not found\" in str(exc_info.value).lower()\n    \n    def test_save_to_json(self, processor, tmp_path):\n        \"\"\"Should save processed data to JSON.\"\"\"\n        records = [{\"id\": 1, \"name\": \"Test\", \"processed\": True}]\n        output_file = tmp_path / \"output.json\"\n        \n        processor.save_json(records, output_file)\n        \n        assert output_file.exists()\n        saved = json.loads(output_file.read_text())\n        assert len(saved) == 1\n```\n\nKey data processing test patterns:\n1. **Happy path** - Basic valid input\n2. **Empty input** - Edge case that shouldn't crash\n3. **Validation tests** - Each validation rule separately\n4. **Parametrized invalid values** - Multiple bad inputs\n5. **Transformation tests** - Verify data changes\n6. **Partial failures** - Processing continues after errors\n7. **Edge cases** - Unicode, long strings, special chars\n8. **Performance tests** - Large batches\n9. **File handling** - I/O operations"}
{"instruction": "Write tests with mocking for external dependencies", "output": "Here's how to properly mock external services:\n\n```python\nimport pytest\nfrom unittest.mock import Mock, patch, AsyncMock, MagicMock\nfrom datetime import datetime\nimport httpx\n\nfrom app.services.payment import PaymentService, PaymentError\nfrom app.services.email import EmailService\nfrom app.services.inventory import InventoryService\nfrom app.models import Order, Payment\n\n\nclass TestPaymentServiceWithMocking:\n    \"\"\"Test payment service with mocked Stripe API.\"\"\"\n    \n    @pytest.fixture\n    def payment_service(self):\n        return PaymentService(api_key=\"sk_test_xxx\")\n    \n    @pytest.fixture\n    def mock_stripe(self):\n        \"\"\"Mock the stripe module.\"\"\"\n        with patch('app.services.payment.stripe') as mock:\n            yield mock\n    \n    # Basic mocking\n    \n    def test_create_charge_success(self, payment_service, mock_stripe):\n        \"\"\"Successful charge should return charge ID.\"\"\"\n        # Configure mock\n        mock_stripe.Charge.create.return_value = Mock(\n            id=\"ch_123\",\n            status=\"succeeded\",\n            amount=1000\n        )\n        \n        result = payment_service.create_charge(\n            amount=10.00,\n            currency=\"usd\",\n            source=\"tok_visa\"\n        )\n        \n        assert result.charge_id == \"ch_123\"\n        assert result.status == \"succeeded\"\n        \n        # Verify mock was called correctly\n        mock_stripe.Charge.create.assert_called_once_with(\n            amount=1000,  # Converted to cents\n            currency=\"usd\",\n            source=\"tok_visa\"\n        )\n    \n    def test_create_charge_card_declined(self, payment_service, mock_stripe):\n        \"\"\"Declined card should raise PaymentError.\"\"\"\n        # Configure mock to raise exception\n        import stripe\n        mock_stripe.error.CardError = stripe.error.CardError\n        mock_stripe.Charge.create.side_effect = stripe.error.CardError(\n            message=\"Your card was declined\",\n            param=\"source\",\n            code=\"card_declined\"\n        )\n        \n        with pytest.raises(PaymentError) as exc_info:\n            payment_service.create_charge(\n                amount=10.00,\n                currency=\"usd\",\n                source=\"tok_declined\"\n            )\n        \n        assert \"declined\" in str(exc_info.value).lower()\n    \n    # Async mocking\n    \n    @pytest.mark.asyncio\n    async def test_async_refund(self, payment_service, mock_stripe):\n        \"\"\"Test async refund operation.\"\"\"\n        mock_stripe.Refund.create = AsyncMock(return_value=Mock(\n            id=\"re_123\",\n            status=\"succeeded\"\n        ))\n        \n        result = await payment_service.refund_async(\"ch_123\", amount=5.00)\n        \n        assert result.refund_id == \"re_123\"\n    \n    # Mock with side_effect for multiple calls\n    \n    def test_retry_on_network_error(self, payment_service, mock_stripe):\n        \"\"\"Should retry on transient network errors.\"\"\"\n        # First call fails, second succeeds\n        mock_stripe.Charge.create.side_effect = [\n            httpx.ConnectError(\"Network error\"),\n            Mock(id=\"ch_123\", status=\"succeeded\", amount=1000)\n        ]\n        \n        result = payment_service.create_charge(\n            amount=10.00,\n            currency=\"usd\",\n            source=\"tok_visa\"\n        )\n        \n        assert result.charge_id == \"ch_123\"\n        assert mock_stripe.Charge.create.call_count == 2\n\n\nclass TestOrderServiceWithMultipleMocks:\n    \"\"\"Test order service that depends on multiple external services.\"\"\"\n    \n    @pytest.fixture\n    def mock_payment(self):\n        return Mock(spec=PaymentService)\n    \n    @pytest.fixture\n    def mock_email(self):\n        return Mock(spec=EmailService)\n    \n    @pytest.fixture\n    def mock_inventory(self):\n        return Mock(spec=InventoryService)\n    \n    @pytest.fixture\n    def order_service(self, mock_payment, mock_email, mock_inventory):\n        from app.services.order import OrderService\n        return OrderService(\n            payment=mock_payment,\n            email=mock_email,\n            inventory=mock_inventory\n        )\n    \n    def test_place_order_full_flow(self, order_service, mock_payment, mock_email, mock_inventory):\n        \"\"\"Full order flow should call all services in correct order.\"\"\"\n        # Configure mocks\n        mock_inventory.check_availability.return_value = True\n        mock_inventory.reserve.return_value = \"reservation_123\"\n        mock_payment.create_charge.return_value = Mock(charge_id=\"ch_123\", status=\"succeeded\")\n        \n        order = Order(items=[{\"sku\": \"ABC\", \"quantity\": 2}], total=50.00)\n        \n        result = order_service.place_order(order, payment_token=\"tok_visa\")\n        \n        # Verify call order\n        assert mock_inventory.check_availability.called\n        assert mock_inventory.reserve.called\n        assert mock_payment.create_charge.called\n        assert mock_email.send_confirmation.called\n        \n        # Verify correct data passed\n        mock_payment.create_charge.assert_called_with(\n            amount=50.00,\n            currency=\"usd\",\n            source=\"tok_visa\"\n        )\n    \n    def test_place_order_payment_fails_releases_inventory(self, order_service, mock_payment, mock_inventory):\n        \"\"\"Failed payment should release inventory reservation.\"\"\"\n        mock_inventory.check_availability.return_value = True\n        mock_inventory.reserve.return_value = \"reservation_123\"\n        mock_payment.create_charge.side_effect = PaymentError(\"Card declined\")\n        \n        order = Order(items=[{\"sku\": \"ABC\", \"quantity\": 2}], total=50.00)\n        \n        with pytest.raises(PaymentError):\n            order_service.place_order(order, payment_token=\"tok_declined\")\n        \n        # Inventory should be released\n        mock_inventory.release.assert_called_once_with(\"reservation_123\")\n    \n    def test_place_order_out_of_stock(self, order_service, mock_inventory, mock_payment):\n        \"\"\"Out of stock should not attempt payment.\"\"\"\n        mock_inventory.check_availability.return_value = False\n        \n        order = Order(items=[{\"sku\": \"ABC\", \"quantity\": 100}], total=5000.00)\n        \n        with pytest.raises(Exception) as exc_info:\n            order_service.place_order(order, payment_token=\"tok_visa\")\n        \n        assert \"stock\" in str(exc_info.value).lower()\n        # Payment should NOT have been called\n        mock_payment.create_charge.assert_not_called()\n\n\nclass TestHTTPClientMocking:\n    \"\"\"Test HTTP client interactions.\"\"\"\n    \n    @pytest.fixture\n    def api_client(self):\n        from app.clients.weather import WeatherClient\n        return WeatherClient(api_key=\"test_key\")\n    \n    @pytest.mark.asyncio\n    async def test_fetch_weather_success(self, api_client):\n        \"\"\"Mock HTTP response for weather API.\"\"\"\n        mock_response = Mock()\n        mock_response.status_code = 200\n        mock_response.json.return_value = {\n            \"temperature\": 72,\n            \"conditions\": \"sunny\"\n        }\n        \n        with patch.object(api_client._client, 'get', new_callable=AsyncMock) as mock_get:\n            mock_get.return_value = mock_response\n            \n            result = await api_client.get_weather(\"New York\")\n            \n            assert result[\"temperature\"] == 72\n            mock_get.assert_called_once()\n    \n    @pytest.mark.asyncio\n    async def test_fetch_weather_with_respx(self, api_client):\n        \"\"\"Use respx for more realistic HTTP mocking.\"\"\"\n        import respx\n        \n        with respx.mock:\n            respx.get(\"https://api.weather.com/v1/current\").mock(\n                return_value=httpx.Response(200, json={\n                    \"temperature\": 72,\n                    \"conditions\": \"sunny\"\n                })\n            )\n            \n            result = await api_client.get_weather(\"New York\")\n            \n            assert result[\"temperature\"] == 72\n\n\nclass TestDatabaseMocking:\n    \"\"\"Test database interactions with mocking.\"\"\"\n    \n    @pytest.fixture\n    def mock_session(self):\n        \"\"\"Create mock SQLAlchemy session.\"\"\"\n        session = Mock()\n        session.commit = Mock()\n        session.rollback = Mock()\n        session.add = Mock()\n        session.delete = Mock()\n        return session\n    \n    @pytest.fixture\n    def user_repo(self, mock_session):\n        from app.repositories.user import UserRepository\n        return UserRepository(session=mock_session)\n    \n    def test_create_user(self, user_repo, mock_session):\n        \"\"\"Test user creation with mocked session.\"\"\"\n        user_data = {\"email\": \"test@example.com\", \"name\": \"Test\"}\n        \n        user = user_repo.create(user_data)\n        \n        mock_session.add.assert_called_once()\n        mock_session.commit.assert_called_once()\n    \n    def test_create_user_rollback_on_error(self, user_repo, mock_session):\n        \"\"\"Should rollback on database error.\"\"\"\n        mock_session.commit.side_effect = Exception(\"DB Error\")\n        \n        with pytest.raises(Exception):\n            user_repo.create({\"email\": \"test@example.com\"})\n        \n        mock_session.rollback.assert_called_once()\n    \n    def test_find_user_query_building(self, user_repo, mock_session):\n        \"\"\"Verify correct query is built.\"\"\"\n        # Setup mock query chain\n        mock_query = Mock()\n        mock_session.query.return_value = mock_query\n        mock_query.filter.return_value = mock_query\n        mock_query.first.return_value = Mock(id=1, email=\"test@example.com\")\n        \n        user = user_repo.find_by_email(\"test@example.com\")\n        \n        # Verify query was called\n        mock_session.query.assert_called_once()\n        mock_query.filter.assert_called_once()\n\n\nclass TestMockingBestPractices:\n    \"\"\"Examples of mocking best practices.\"\"\"\n    \n    def test_use_spec_for_type_safety(self):\n        \"\"\"Use spec to catch typos in mock usage.\"\"\"\n        from app.services.email import EmailService\n        \n        # With spec, accessing non-existent method raises AttributeError\n        mock = Mock(spec=EmailService)\n        \n        # This would raise AttributeError if send_emal doesn't exist:\n        # mock.send_emal()  # Typo caught!\n        \n        mock.send_email(to=\"test@example.com\", subject=\"Hi\")\n        mock.send_email.assert_called_once()\n    \n    def test_use_autospec_for_signature_validation(self):\n        \"\"\"Use autospec to validate call signatures.\"\"\"\n        from app.services.email import EmailService\n        \n        mock = create_autospec(EmailService)\n        \n        # This would raise TypeError if signature doesn't match:\n        # mock.send_email(wrong_arg=True)\n        \n        mock.send_email(to=\"test@example.com\", subject=\"Hi\", body=\"Hello\")\n    \n    def test_verify_mock_was_called_with_any(self):\n        \"\"\"Use ANY for partial argument matching.\"\"\"\n        from unittest.mock import ANY\n        \n        mock_logger = Mock()\n        \n        # Function under test\n        def process_with_logging(data):\n            mock_logger.info(f\"Processing at {datetime.now()}: {data}\")\n        \n        process_with_logging(\"test data\")\n        \n        # We don't care about exact timestamp\n        mock_logger.info.assert_called_once()\n        call_arg = mock_logger.info.call_args[0][0]\n        assert \"test data\" in call_arg\n    \n    def test_reset_mock_between_tests(self):\n        \"\"\"Reset mocks to avoid test pollution.\"\"\"\n        mock = Mock()\n        mock.method(\"first call\")\n        \n        mock.reset_mock()\n        \n        mock.method(\"second call\")\n        mock.method.assert_called_once_with(\"second call\")\n```\n\nKey mocking patterns:\n1. **Use spec** - Catch typos and invalid method calls\n2. **side_effect for sequences** - Different responses per call\n3. **side_effect for exceptions** - Test error handling\n4. **AsyncMock** - For async functions\n5. **Verify call order** - assert_called_once, call_count\n6. **Verify arguments** - assert_called_with, ANY for partial\n7. **Reset between tests** - Avoid pollution\n8. **Context managers** - patch() for temporary mocks"}
{"instruction": "Write test fixtures and conftest setup", "output": "Here's how to organize test fixtures properly:\n\n```python\n# conftest.py - Shared fixtures for all tests\n\nimport pytest\nimport asyncio\nfrom typing import Generator, AsyncGenerator\nfrom unittest.mock import Mock, AsyncMock\nfrom pathlib import Path\nimport tempfile\nimport shutil\nimport os\n\n# Database fixtures\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom app.database import Base, get_db\nfrom app.main import app\n\n\n# ============================================\n# Configuration\n# ============================================\n\ndef pytest_configure(config):\n    \"\"\"Configure pytest with custom markers.\"\"\"\n    config.addinivalue_line(\"markers\", \"slow: mark test as slow running\")\n    config.addinivalue_line(\"markers\", \"integration: mark as integration test\")\n    config.addinivalue_line(\"markers\", \"e2e: mark as end-to-end test\")\n\n\ndef pytest_collection_modifyitems(config, items):\n    \"\"\"Skip slow tests unless --runslow is passed.\"\"\"\n    if config.getoption(\"--runslow\", default=False):\n        return\n    \n    skip_slow = pytest.mark.skip(reason=\"need --runslow option to run\")\n    for item in items:\n        if \"slow\" in item.keywords:\n            item.add_marker(skip_slow)\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add custom command line options.\"\"\"\n    parser.addoption(\n        \"--runslow\",\n        action=\"store_true\",\n        default=False,\n        help=\"run slow tests\"\n    )\n\n\n# ============================================\n# Database Fixtures\n# ============================================\n\n@pytest.fixture(scope=\"session\")\ndef db_engine():\n    \"\"\"Create test database engine (session-scoped for performance).\"\"\"\n    engine = create_engine(\n        \"sqlite:///:memory:\",\n        connect_args={\"check_same_thread\": False}\n    )\n    Base.metadata.create_all(bind=engine)\n    yield engine\n    engine.dispose()\n\n\n@pytest.fixture(scope=\"function\")\ndef db_session(db_engine) -> Generator[Session, None, None]:\n    \"\"\"Create fresh database session for each test.\"\"\"\n    connection = db_engine.connect()\n    transaction = connection.begin()\n    \n    TestSession = sessionmaker(bind=connection)\n    session = TestSession()\n    \n    yield session\n    \n    session.close()\n    transaction.rollback()\n    connection.close()\n\n\n@pytest.fixture(scope=\"function\")\ndef override_db(db_session):\n    \"\"\"Override FastAPI database dependency.\"\"\"\n    def _get_test_db():\n        try:\n            yield db_session\n        finally:\n            pass\n    \n    app.dependency_overrides[get_db] = _get_test_db\n    yield db_session\n    app.dependency_overrides.clear()\n\n\n# ============================================\n# HTTP Client Fixtures\n# ============================================\n\n@pytest.fixture(scope=\"function\")\nasync def client(override_db) -> AsyncGenerator:\n    \"\"\"Async HTTP client for API testing.\"\"\"\n    from httpx import AsyncClient, ASGITransport\n    \n    async with AsyncClient(\n        transport=ASGITransport(app=app),\n        base_url=\"http://test\"\n    ) as ac:\n        yield ac\n\n\n@pytest.fixture(scope=\"function\")\ndef sync_client(override_db):\n    \"\"\"Sync HTTP client for non-async tests.\"\"\"\n    from fastapi.testclient import TestClient\n    \n    with TestClient(app) as client:\n        yield client\n\n\n# ============================================\n# Authentication Fixtures\n# ============================================\n\n@pytest.fixture\ndef test_user(db_session):\n    \"\"\"Create a test user in database.\"\"\"\n    from app.models import User\n    from app.auth import hash_password\n    \n    user = User(\n        email=\"test@example.com\",\n        hashed_password=hash_password(\"TestPassword123\"),\n        is_active=True\n    )\n    db_session.add(user)\n    db_session.commit()\n    db_session.refresh(user)\n    return user\n\n\n@pytest.fixture\ndef admin_user(db_session):\n    \"\"\"Create an admin user.\"\"\"\n    from app.models import User\n    from app.auth import hash_password\n    \n    user = User(\n        email=\"admin@example.com\",\n        hashed_password=hash_password(\"AdminPassword123\"),\n        is_active=True,\n        is_admin=True\n    )\n    db_session.add(user)\n    db_session.commit()\n    db_session.refresh(user)\n    return user\n\n\n@pytest.fixture\ndef auth_headers(test_user):\n    \"\"\"Generate auth headers for test user.\"\"\"\n    from app.auth import create_access_token\n    token = create_access_token(user_id=test_user.id)\n    return {\"Authorization\": f\"Bearer {token}\"}\n\n\n@pytest.fixture\ndef admin_headers(admin_user):\n    \"\"\"Generate auth headers for admin user.\"\"\"\n    from app.auth import create_access_token\n    token = create_access_token(user_id=admin_user.id, extra_data={\"is_admin\": True})\n    return {\"Authorization\": f\"Bearer {token}\"}\n\n\n# ============================================\n# File System Fixtures\n# ============================================\n\n@pytest.fixture\ndef temp_dir() -> Generator[Path, None, None]:\n    \"\"\"Create temporary directory that's cleaned up after test.\"\"\"\n    path = Path(tempfile.mkdtemp())\n    yield path\n    shutil.rmtree(path, ignore_errors=True)\n\n\n@pytest.fixture\ndef sample_csv(temp_dir) -> Path:\n    \"\"\"Create sample CSV file for testing.\"\"\"\n    csv_path = temp_dir / \"sample.csv\"\n    csv_path.write_text(\n        \"id,name,email\\n\"\n        \"1,Alice,alice@example.com\\n\"\n        \"2,Bob,bob@example.com\\n\"\n    )\n    return csv_path\n\n\n@pytest.fixture\ndef sample_json(temp_dir) -> Path:\n    \"\"\"Create sample JSON file for testing.\"\"\"\n    import json\n    json_path = temp_dir / \"sample.json\"\n    json_path.write_text(json.dumps([\n        {\"id\": 1, \"name\": \"Alice\"},\n        {\"id\": 2, \"name\": \"Bob\"}\n    ]))\n    return json_path\n\n\n# ============================================\n# Mock Service Fixtures\n# ============================================\n\n@pytest.fixture\ndef mock_email_service():\n    \"\"\"Mock email service that tracks sent emails.\"\"\"\n    mock = Mock()\n    mock.sent_emails = []\n    \n    def track_email(to, subject, body):\n        mock.sent_emails.append({\"to\": to, \"subject\": subject, \"body\": body})\n        return True\n    \n    mock.send_email.side_effect = track_email\n    return mock\n\n\n@pytest.fixture\ndef mock_payment_service():\n    \"\"\"Mock payment service.\"\"\"\n    mock = Mock()\n    mock.create_charge.return_value = Mock(\n        charge_id=\"ch_test_123\",\n        status=\"succeeded\"\n    )\n    mock.refund.return_value = Mock(\n        refund_id=\"re_test_123\",\n        status=\"succeeded\"\n    )\n    return mock\n\n\n@pytest.fixture\ndef mock_external_api():\n    \"\"\"Mock for external HTTP APIs.\"\"\"\n    mock = AsyncMock()\n    mock.get.return_value = Mock(\n        status_code=200,\n        json=Mock(return_value={\"status\": \"ok\"})\n    )\n    return mock\n\n\n# ============================================\n# Data Fixtures\n# ============================================\n\n@pytest.fixture\ndef sample_user_data():\n    \"\"\"Sample user data for testing.\"\"\"\n    return {\n        \"email\": \"newuser@example.com\",\n        \"password\": \"SecurePassword123\",\n        \"name\": \"New User\"\n    }\n\n\n@pytest.fixture\ndef sample_items():\n    \"\"\"Sample items for testing.\"\"\"\n    return [\n        {\"name\": \"Item 1\", \"price\": 10.00, \"quantity\": 5},\n        {\"name\": \"Item 2\", \"price\": 20.00, \"quantity\": 3},\n        {\"name\": \"Item 3\", \"price\": 15.00, \"quantity\": 10},\n    ]\n\n\n@pytest.fixture(params=[\n    {\"name\": \"Valid Item\", \"price\": 10.00},\n    {\"name\": \"Expensive Item\", \"price\": 9999.99},\n    {\"name\": \"Cheap Item\", \"price\": 0.01},\n])\ndef valid_item_data(request):\n    \"\"\"Parametrized fixture for valid item variations.\"\"\"\n    return request.param\n\n\n# ============================================\n# Environment Fixtures\n# ============================================\n\n@pytest.fixture\ndef env_vars(monkeypatch):\n    \"\"\"Set environment variables for testing.\"\"\"\n    def _set_env(**kwargs):\n        for key, value in kwargs.items():\n            monkeypatch.setenv(key, value)\n    return _set_env\n\n\n@pytest.fixture(autouse=True)\ndef reset_singletons():\n    \"\"\"Reset any singletons between tests.\"\"\"\n    yield\n    # Clean up singletons here if needed\n    from app.services import _instances\n    _instances.clear()\n\n\n# ============================================\n# Async Event Loop Fixture\n# ============================================\n\n@pytest.fixture(scope=\"session\")\ndef event_loop():\n    \"\"\"Create event loop for async tests.\"\"\"\n    loop = asyncio.new_event_loop()\n    yield loop\n    loop.close()\n\n\n# ============================================\n# Factories\n# ============================================\n\n@pytest.fixture\ndef user_factory(db_session):\n    \"\"\"Factory for creating users with custom attributes.\"\"\"\n    from app.models import User\n    from app.auth import hash_password\n    \n    created_users = []\n    \n    def _create_user(\n        email: str = None,\n        password: str = \"TestPassword123\",\n        is_active: bool = True,\n        **kwargs\n    ) -> User:\n        if email is None:\n            email = f\"user_{len(created_users) + 1}@example.com\"\n        \n        user = User(\n            email=email,\n            hashed_password=hash_password(password),\n            is_active=is_active,\n            **kwargs\n        )\n        db_session.add(user)\n        db_session.commit()\n        db_session.refresh(user)\n        created_users.append(user)\n        return user\n    \n    yield _create_user\n    \n    # Cleanup handled by db_session transaction rollback\n\n\n@pytest.fixture\ndef item_factory(db_session, test_user):\n    \"\"\"Factory for creating items.\"\"\"\n    from app.models import Item\n    \n    def _create_item(\n        name: str = \"Test Item\",\n        price: float = 10.00,\n        owner_id: int = None,\n        **kwargs\n    ) -> Item:\n        item = Item(\n            name=name,\n            price=price,\n            owner_id=owner_id or test_user.id,\n            **kwargs\n        )\n        db_session.add(item)\n        db_session.commit()\n        db_session.refresh(item)\n        return item\n    \n    return _create_item\n```\n\nKey fixture patterns:\n1. **Scope levels** - session, module, function\n2. **Database with rollback** - Clean state per test\n3. **Dependency overrides** - For FastAPI\n4. **Factory fixtures** - Create entities with custom attrs\n5. **Parametrized fixtures** - Multiple test variations\n6. **Cleanup** - Temp files, rollback, singleton reset\n7. **Auth helpers** - Headers for protected endpoints\n8. **Custom markers** - slow, integration, e2e"}
