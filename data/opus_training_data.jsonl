{"instruction": "Skapa ett n8n workflow som orkestrerar flera AI-agenter med Ollama RAG och specialiserade services", "output": "## AI Agent Orchestrator med Ollama RAG\n\n### Arkitektur\nWorkflowet använder en central orchestrator-agent som koordinerar specialiserade n8n workflow-services via HTTP webhooks.\n\n### Komponenter\n1. **Webhook Trigger** - Tar emot användarförfrågningar via POST\n2. **Workflow Configuration** - Centraliserad konfiguration för alla service-URLs\n3. **Orchestrator Agent** - LangChain agent med Ollama som koordinerar tools\n4. **RAG Vector Store** - In-memory vektor-databas för kontextuell kunskap\n5. **Specialized Service Tools** - HTTP Request Tools för Database, Sentiment, PDF services\n\n### Implementation\n```javascript\n// Orchestrator System Prompt\nconst systemMessage = `You are an orchestrator agent that coordinates specialized n8n workflow services.\n\nYour role is to:\n1. Analyze the user request and determine which specialized services are needed\n2. Call the appropriate service tools in the correct sequence\n3. Coordinate data flow between services\n4. Use the RAG knowledge base when you need contextual information\n5. Return the final result to the user`;\n\n// Service Tool Configuration\nconst databaseServiceTool = {\n  toolDescription: \"Calls the specialized database service workflow\",\n  method: \"POST\",\n  url: \"{{ $('Workflow Configuration').first().json.databaseServiceUrl }}\",\n  bodyParameters: {\n    query: \"{{ $fromAI('query', 'The database query to perform') }}\",\n    parameters: \"{{ $fromAI('parameters', 'Query parameters as JSON', 'json', {}) }}\"\n  }\n};\n```\n\n### Best Practices\n- Använd `retrieve-as-tool` mode för RAG vector store\n- Separera services i egna workflows för moduläritet\n- Inkludera `includeOtherFields: true` i Set-noder för att bevara data"}
{"instruction": "Bygg ett multi-source business intelligence system med AI-driven analytics i n8n", "output": "## AI-Driven Multi-Source Business Intelligence\n\n### Syfte\nSamla data från flera källor, analysera med AI och leverera insikter anpassade för olika målgrupper.\n\n### Dataflöde\n```\nMultiple Sources → Normalize → AI Analysis → Audience Adaptation → Delivery\n```\n\n### Komponenter\n1. **Data Sources** - Google Sheets, APIs, Databases\n2. **Data Normalization** - Set-noder som standardiserar format\n3. **AI Analysis Agent** - LangChain agent för intelligent analys\n4. **Audience Adaptation** - Switch-nod som routar till rätt format\n5. **Delivery Channels** - Slack, Email, Dashboard\n\n### Implementation\n```javascript\n// Normalize data from different sources\nconst normalizeData = {\n  assignments: [\n    { name: \"dataType\", value: \"={{ $json.type || 'unknown' }}\" },\n    { name: \"value\", value: \"={{ $json.amount || $json.value || 0 }}\" },\n    { name: \"timestamp\", value: \"={{ $json.date || $now.toISO() }}\" },\n    { name: \"source\", value: \"={{ $json.source || 'manual' }}\" }\n  ]\n};\n\n// AI Analysis System Prompt\nconst analysisPrompt = `Analyze this business data and provide:\n1. Key trends and patterns\n2. Anomalies that need attention\n3. Actionable recommendations\n4. Risk assessment\n\nBe data-driven and specific.`;\n```\n\n### Tips\n- Använd Merge-nod med `combineAll` för att samla alla datakällor\n- Implementera caching för frekventa API-anrop\n- Logga alla analyser för audit trail"}
{"instruction": "Skapa ett automatiskt dokumentationssystem som genererar docs från GitHub, Slack, Jira och Linear events", "output": "## Auto-Generated Internal Documentation System\n\n### Arkitektur\nWorkflowet lyssnar på events från utvecklingsverktyg och genererar automatiskt strukturerad dokumentation.\n\n### Event Sources\n1. **GitHub Webhook** - Push, PR, Issues\n2. **Slack Webhook** - Viktiga diskussioner\n3. **Jira Webhook** - Issue updates\n4. **Linear Webhook** - Task changes\n\n### AI Agents Pipeline\n```\nEvent → Normalize → Context Analyzer → Route by Type → Specialized Writer → Vector Store → Output\n```\n\n### Implementation\n```javascript\n// Normalize Event Data\nconst normalizeEvent = {\n  eventType: \"={{ $json.body.action || $json.body.event?.type || 'unknown' }}\",\n  eventSource: \"={{ $json.headers['x-github-event'] ? 'github' : $json.headers['x-slack-signature'] ? 'slack' : 'unknown' }}\",\n  eventTitle: \"={{ $json.body.pull_request?.title || $json.body.issue?.title || 'No title' }}\",\n  eventDescription: \"={{ $json.body.pull_request?.body || $json.body.issue?.body || '' }}\",\n  eventAuthor: \"={{ $json.body.sender?.login || $json.body.user?.name || 'Unknown' }}\"\n};\n\n// Context Analyzer Agent\nconst analyzerPrompt = `Analyze this development event and determine:\n1. What changed or happened?\n2. Why did it happen? (extract intent)\n3. What systems/components are affected?\n4. What type of documentation should be updated?\n\nDocumentation types:\n- architecture: System design changes\n- api: API endpoints, formats\n- changelog: User-facing changes\n- lessons: Problems and solutions found`;\n\n// Specialized Writers\nconst architectureWriter = {\n  systemMessage: `You are an architecture documentation writer.\n  - Describe system components and relationships\n  - Explain architectural decisions\n  - Use Mermaid diagrams when relevant\n  - Maintain continuity with existing docs`\n};\n```\n\n### Output Destinations\n- **Notion** - Structured database pages\n- **GitHub Docs** - Markdown files in repo\n- **Confluence** - Wiki pages\n- **Qdrant** - Vector storage for RAG"}
{"instruction": "Implementera ett intelligent RAG-system med Ollama som har multiple tools och cross-document intelligence", "output": "## Intelligent RAG Ollama Multi-Function System\n\n### Funktioner\n- RAG-baserad Q&A med lokal Ollama\n- Real-time API integration\n- Email/Slack actions\n- Cross-document relationship analysis\n\n### Komponenter\n```\nQuery → Config → RAG Agent → Tools → Actions → Response\n         ↓\n    Auto-Update → Fetch → Clean → Vector Store → Intelligence\n```\n\n### Implementation\n```javascript\n// Workflow Configuration\nconst config = {\n  ollamaModel: \"llama3.2\",\n  embeddingModel: \"nomic-embed-text\",\n  chunkSize: 1000,\n  chunkOverlap: 200\n};\n\n// RAG Orchestrator Agent\nconst ragPrompt = `Du är en intelligent RAG-assistent på svenska.\n\nTillgängliga verktyg:\n1. knowledge_base_search: Sök i kunskapsbasen\n2. fetch_live_data: Hämta realtidsdata\n3. Gmail/Slack: Skicka meddelanden\n4. schedule_reminder: Schemalägg uppgifter\n\nAnvänd rätt verktyg, kombinera data, förklara källor.`;\n\n// Cross-Document Intelligence (Code Node)\nfunction analyzeRelationships(documents) {\n  const extractKeyTerms = (text) => {\n    return text.toLowerCase()\n      .replace(/[^\\w\\s]/g, ' ')\n      .split(/\\s+/)\n      .filter(word => word.length > 4);\n  };\n  \n  const calculateSimilarity = (doc1, doc2) => {\n    const terms1 = new Set(extractKeyTerms(doc1.content));\n    const terms2 = new Set(extractKeyTerms(doc2.content));\n    const intersection = [...terms1].filter(x => terms2.has(x));\n    const union = new Set([...terms1, ...terms2]);\n    return intersection.length / union.size; // Jaccard similarity\n  };\n  \n  // Build knowledge graph\n  const knowledgeGraph = { nodes: [], edges: [] };\n  // ... implementation\n  return knowledgeGraph;\n}\n```\n\n### Swedish Document Handling\n```javascript\n// Normalize Swedish characters\ncontent = content\n  .replace(/Ã¥/g, 'å')\n  .replace(/Ã¤/g, 'ä')\n  .replace(/Ã¶/g, 'ö');\n```"}
{"instruction": "Bygg ett Second Brain cognitive engine med multi-source intelligence processing i n8n", "output": "## Second Brain Cognitive Engine\n\n### Koncept\nEtt personligt AI-system som samlar, analyserar och organiserar information från alla dina digitala källor.\n\n### Data Sources\n1. **Gmail** - Email trigger var 5:e minut\n2. **Google Drive** - Document changes\n3. **Google Calendar** - Event updates\n4. **Slack** - Important messages\n\n### AI Agent Architecture\n```\n┌─────────────────────────────────────────────┐\n│           ORCHESTRATOR AGENT                │\n├─────────────────────────────────────────────┤\n│  ┌─────────┐ ┌─────────┐ ┌─────────┐       │\n│  │Classifier│ │Summarizer│ │Task     │       │\n│  │Agent    │ │Agent    │ │Extractor│       │\n│  └─────────┘ └─────────┘ └─────────┘       │\n│  ┌─────────┐ ┌─────────┐                   │\n│  │Priority │ │Context  │                   │\n│  │Planner  │ │Finder   │                   │\n│  └─────────┘ └─────────┘                   │\n└─────────────────────────────────────────────┘\n```\n\n### Implementation\n```javascript\n// Normalize all sources to common format\nconst normalizeEmail = {\n  sourceType: \"email\",\n  content: \"={{ $json.textPlain || $json.textHtml }}\",\n  title: \"={{ $json.subject }}\",\n  timestamp: \"={{ $json.date }}\",\n  sender: \"={{ $json.from.address }}\"\n};\n\n// Classifier Agent Tool\nconst classifierPrompt = `Categorize into ONE category:\n- economy (financial matters)\n- health (medical, fitness)\n- relationships (personal)\n- projects (work initiatives)\n- tasks (actionable items)\n- ideas (creative thoughts)\n- knowledge (learning)\nReturn ONLY the category name.`;\n\n// Task Extractor with Output Parser\nconst taskSchema = {\n  type: \"object\",\n  properties: {\n    tasks: {\n      type: \"array\",\n      items: {\n        type: \"object\",\n        properties: {\n          description: { type: \"string\" },\n          deadline: { type: \"string\" },\n          priority: { type: \"string\" },\n          context: { type: \"string\" }\n        }\n      }\n    }\n  }\n};\n\n// Priority Planner - 3-day action plan\nconst plannerPrompt = `Create a 3-day action plan.\nConsider:\n- Deadlines and time sensitivity\n- Impact and importance\n- Dependencies between tasks\n- Realistic capacity (3-5 tasks/day)`;\n```\n\n### Output Channels\n- **Slack** - Daily summary with mrkdwn formatting\n- **Notion** - Structured archive database\n- **Vector Store** - Long-term memory for RAG"}
{"instruction": "Skapa ett automatiskt fakturapåminnelse-system med n8n", "output": "## Automated Invoice Payment Reminder System\n\n### Funktionalitet\nAutomatiska påminnelser vid T-3, förfallodatum och +7 dagar.\n\n### Workflow\n```\nDaily Check → Get Invoices → Calculate Stage → Filter → Prepare Email → Send → Log\n```\n\n### Implementation\n```javascript\n// Calculate Reminder Stage (Code Node)\nconst dueDate = new Date($input.item.json.dueDate);\nconst isPaid = $input.item.json.isPaid === 'TRUE';\nconst lastReminderSent = $input.item.json.lastReminderSent || '';\nconst today = new Date();\n\nconst daysUntilDue = Math.floor((dueDate - today) / (1000 * 60 * 60 * 24));\n\nlet reminderStage = null;\nlet shouldSendReminder = false;\n\nif (!isPaid) {\n  if (daysUntilDue === 3 && lastReminderSent !== 'T-3') {\n    reminderStage = 'T-3';\n    shouldSendReminder = true;\n  } else if (daysUntilDue === 0 && lastReminderSent !== 'DueDate') {\n    reminderStage = 'DueDate';\n    shouldSendReminder = true;\n  } else if (daysUntilDue === -7 && lastReminderSent !== 'Overdue+7') {\n    reminderStage = 'Overdue+7';\n    shouldSendReminder = true;\n  }\n}\n\nreturn { ...($input.item.json), daysUntilDue, reminderStage, shouldSendReminder };\n\n// Dynamic Email Subject\nconst emailSubject = reminderStage === 'T-3' \n  ? 'Påminnelse: Faktura förfaller om 3 dagar'\n  : reminderStage === 'DueDate'\n  ? 'Påminnelse: Faktura förfaller idag'\n  : 'Viktig påminnelse: Förfallen faktura (7 dagar)';\n```\n\n### Email Template (HTML)\n```html\n<div style=\"background-color: #f5f5f5; padding: 15px;\">\n  <strong>Fakturadetaljer:</strong><br>\n  Fakturanummer: {{ $json.invoiceNumber }}<br>\n  Belopp: {{ $json.amount }} SEK<br>\n  Förfallodatum: {{ $json.dueDate }}\n</div>\n<a href=\"{{ paymentLink }}\" style=\"background-color: #4CAF50; color: white; padding: 12px 24px;\">Betala nu</a>\n```\n\n### Google Sheets Integration\n- Läs fakturalista med `returnFirstMatch: false`\n- Uppdatera `lastReminderSent` och `lastReminderDate` efter skickat"}
{"instruction": "Hur strukturerar jag ett n8n workflow med AI-agenter och verktyg?", "output": "## n8n AI Agent Workflow Structure\n\n### Grundläggande Pattern\n```\nTrigger → Configuration → Agent → Tools → Output\n                           ↓\n                    Language Model\n                           ↓\n                      Memory/RAG\n```\n\n### Best Practices\n\n#### 1. Workflow Configuration Node\nAnvänd alltid en Set-nod i början för konfiguration:\n```javascript\n{\n  assignments: [\n    { name: \"apiUrl\", value: \"<PLACEHOLDER>\", type: \"string\" },\n    { name: \"modelName\", value: \"gpt-4.1-mini\", type: \"string\" },\n    { name: \"maxTokens\", value: 2048, type: \"number\" }\n  ],\n  includeOtherFields: true\n}\n```\n\n#### 2. Agent Node Setup\n```javascript\n// Använd promptType: \"define\" för full kontroll\n{\n  promptType: \"define\",\n  text: \"={{ $json.userInput }}\",\n  options: {\n    systemMessage: \"Du är en hjälpsam assistent...\"\n  }\n}\n```\n\n#### 3. Tool Connections\nKoppla verktyg via `ai_tool` connection type:\n- Vector Store som tool → `mode: \"retrieve-as-tool\"`\n- HTTP Request Tool → `toolDescription` är kritisk\n- Code Tool → Returnera alltid JSON.stringify()\n\n#### 4. Output Parsers\nFör strukturerad output:\n```javascript\n// Structured Output Parser\n{\n  schemaType: \"manual\",\n  inputSchema: JSON.stringify(yourSchema),\n  autoFix: true  // LLM fixar formatfel\n}\n```\n\n#### 5. Memory\n```javascript\n// Buffer Window Memory\n{\n  sessionKey: \"={{ $json.sessionId || 'default' }}\",\n  contextWindowLength: 10  // Antal meddelanden att minnas\n}\n```\n\n### Vanliga Misstag\n1. Glömmer `includeOtherFields: true` → tappar data\n2. Fel `typeVersion` → nod fungerar inte\n3. Saknar `toolDescription` → agent kan inte använda tool\n4. Hårdkodar värden istället för expressions"}
{"instruction": "Hur implementerar jag RAG med Vector Store i n8n?", "output": "## RAG Implementation i n8n\n\n### Två Modes\n1. **Insert Mode** - Lägg till dokument i vector store\n2. **Retrieve-as-Tool Mode** - Sök som agent tool\n\n### Insert Pipeline\n```\nData Source → Document Loader → Text Splitter → Embeddings → Vector Store (insert)\n```\n\n### Implementation\n```javascript\n// 1. Document Loader\n{\n  textSplittingMode: \"custom\",\n  jsonMode: \"expressionData\",\n  jsonData: \"={{ $json }}\"\n}\n\n// 2. Recursive Text Splitter\n{\n  chunkSize: 1000,\n  chunkOverlap: 200  // 20% overlap är standard\n}\n\n// 3. Embeddings (Ollama eller OpenAI)\n// Ollama:\n{ model: \"nomic-embed-text\" }\n// OpenAI:\n{ model: \"text-embedding-3-small\" }\n\n// 4. Vector Store - Insert\n{\n  mode: \"insert\",\n  memoryKey: \"my_knowledge_base\"\n}\n```\n\n### Retrieve som Tool\n```javascript\n// Vector Store - Retrieve as Tool\n{\n  mode: \"retrieve-as-tool\",\n  toolDescription: \"Sök i kunskapsbasen för att hitta relevant information\",\n  memoryKey: \"my_knowledge_base\",\n  topK: 5  // Antal resultat att returnera\n}\n```\n\n### Qdrant Integration (Persistent)\n```javascript\n// Qdrant Vector Store\n{\n  qdrantCollection: {\n    __rl: true,\n    mode: \"id\",\n    value: \"={{ $('Config').first().json.collectionName }}\"\n  }\n}\n```\n\n### Tips\n- Använd `In-Memory` för utveckling, `Qdrant` för produktion\n- `topK: 5` är bra default, öka vid behov\n- `toolDescription` måste vara tydlig för att agent ska använda rätt"}
{"instruction": "Skapa ett multipart memory ingestion system som hanterar audio, bild, PDF, URL och text med AI-processning och vector storage", "output": "## Multipart Memory Ingestion System\n\n### Arkitektur\nWebhook-baserat system som tar emot olika innehållstyper, extraherar text och lagrar i Qdrant vector store.\n\n### Content Type Routing\n```\nWebhook → Parse Multipart → Switch by Type → Process → Summarize → Keywords → Qdrant\n                                │\n                    ┌───────────┼───────────┐\n                    ▼           ▼           ▼\n                  Audio       Image        PDF\n                (Whisper)    (OCR)      (Extract)\n```\n\n### Implementation\n```javascript\n// Parse Multipart Data (Code Node)\nconst parsedData = {\n  type: body.type || null,\n  title: body.title || null,\n  text: body.text || null,\n  source: body.source || null,\n  timestamp: body.timestamp || new Date().toISOString(),\n  metadata: body.metadata || {},\n  user_id: body.user_id || null\n};\n\n// Handle binary file if present\nif (item.binary && Object.keys(item.binary).length > 0) {\n  binaryData = item.binary;\n  parsedData.file = Object.keys(item.binary)[0];\n}\n\n// Extract Keywords (Code Node)\nfunction extractKeywords(text) {\n  const stopWords = new Set(['the', 'a', 'an', 'and', 'or', ...]);\n  const words = text.toLowerCase()\n    .replace(/[^a-z0-9\\s]/g, ' ')\n    .split(/\\s+/)\n    .filter(word => word.length > 3 && !stopWords.has(word));\n  \n  const wordCount = {};\n  words.forEach(word => wordCount[word] = (wordCount[word] || 0) + 1);\n  \n  return Object.entries(wordCount)\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 10)\n    .map(entry => entry[0]);\n}\n```\n\n### Content Processors\n- **Audio**: OpenAI Whisper transcription\n- **Image**: OCR via extractFromFile\n- **URL**: HTTP Request med responseFormat: text\n- **PDF**: extractFromFile med operation: pdf\n- **Text**: Direkt genomströmning\n\n### Vector Storage\n```javascript\n// Qdrant Insert\n{\n  mode: \"insert\",\n  qdrantCollection: \"{{ $('Config').first().json.qdrantCollection }}\"\n}\n\n// Search endpoint\n{\n  mode: \"load\",\n  prompt: \"{{ $json.query }}\",\n  topK: \"{{ $json.topK }}\"\n}\n```"}
{"instruction": "Implementera bidirectional data sync mellan Linear, Gmail, Calendar, Notion och Slack med conflict resolution", "output": "## Multi-Platform Bidirectional Data Sync\n\n### Funktionalitet\n- Synkar data mellan 5 plattformar var 15:e minut\n- Normaliserar data till gemensamt format\n- Hanterar konflikter med configuerbar strategi\n- Sparar sync state för incremental updates\n\n### Sync Flow\n```\nSchedule → Server Check → Load State → Fetch All → Normalize → Detect Changes → Resolve Conflicts → Route → Update → Save State\n```\n\n### Data Normalization (Code Node)\n```javascript\n// Detect platform from data structure\nlet platform, id, title, description, timestamp, status, metadata;\n\n// Linear Issues\nif (json.identifier || json.team) {\n  platform = 'linear';\n  id = json.id || json.identifier;\n  title = json.title || '';\n  status = json.state?.name || '';\n  metadata = { assignee: json.assignee?.name, priority: json.priority };\n}\n// Gmail Messages  \nelse if (json.threadId || json.labelIds) {\n  platform = 'gmail';\n  id = json.id || json.threadId;\n  title = json.subject || '';\n  status = json.labelIds?.includes('UNREAD') ? 'unread' : 'read';\n}\n// Google Calendar\nelse if (json.start?.dateTime) {\n  platform = 'calendar';\n  title = json.summary || '';\n  metadata = { start: json.start, end: json.end, attendees: json.attendees };\n}\n// Notion\nelse if (json.properties || json.object === 'page') {\n  platform = 'notion';\n  title = json.properties?.Name?.title?.[0]?.plain_text || '';\n}\n// Slack\nelse if (json.ts || json.channel) {\n  platform = 'slack';\n  title = json.text?.substring(0, 100) || '';\n}\n```\n\n### Conflict Resolution Strategies\n```javascript\nconst strategy = config.conflictResolutionStrategy; // 'latest_wins' | 'merge' | 'manual_review'\n\nif (strategy === 'latest_wins') {\n  resolved.data = sourceTimestamp > targetTimestamp ? sourceData : targetData;\n} else if (strategy === 'merge') {\n  resolved.data = { ...targetData };\n  for (const [key, value] of Object.entries(sourceData)) {\n    if (!targetData[key]) resolved.data[key] = value;\n    else if (JSON.stringify(targetData[key]) !== JSON.stringify(value)) {\n      resolved.needsManualReview = true;\n      resolved.conflictDetails.push({ field: key, sourceValue: value, targetValue: targetData[key] });\n    }\n  }\n}\n```\n\n### State Management\n```javascript\n// Save Sync State\n{\n  timestamp: $now.toISO(),\n  platforms: { linear, gmail, calendar, notion, slack },\n  lastSync: $now.toISO(),\n  syncStatus: 'completed'\n}\n```"}
{"instruction": "Bygg ett AI-driven newsletter system med Google Drive trigger, AI-generering, approval workflow och automated reminders", "output": "## AI Newsletter Generation System\n\n### Workflow Overview\n1. **Trigger**: Nya filer i Google Drive-mapp\n2. **Process**: Extrahera text, generera med AI\n3. **Store**: Spara draft i PostgreSQL\n4. **Approve**: Webhook för godkännande\n5. **Send**: Skicka via Gmail\n6. **Remind**: Veckovis påminnelse om tomt innehåll\n\n### Implementation\n```javascript\n// Workflow Configuration\n{\n  distributionList: \"team@company.com,all-hands@company.com\",\n  reminderRecipients: \"content-team@company.com\",\n  databaseTable: \"newsletters\"\n}\n\n// Check If Already Processed\n\"SELECT COUNT(*) as count FROM processed_files WHERE file_id = $1\"\n\n// Generate Newsletter with AI\n{\n  model: \"gpt-4o\",\n  messages: [\n    {\n      role: \"system\",\n      content: \"You are a professional newsletter writer. Create well-formatted HTML...\"\n    },\n    { role: \"user\", content: \"={{ $json.text }}\" }\n  ],\n  temperature: 0.7\n}\n\n// Save Newsletter Draft\nINSERT INTO newsletters (id, html_content, status, file_id, created_at)\nVALUES ($1, $2, 'pending', $3, NOW())\n```\n\n### Approval Flow\n```\nPOST /webhook/newsletter-approval\n  → Get Newsletter WHERE status='pending'\n  → Send via Gmail\n  → UPDATE status='sent', sent_at=NOW()\n  → Respond { success: true }\n```\n\n### Weekly Reminder\n```javascript\n// Check Content Last Week\n\"SELECT COUNT(*) FROM processed_files WHERE processed_at >= NOW() - INTERVAL '7 days'\"\n\n// If count = 0, send reminder\nif ($json.count === 0) {\n  sendEmail({\n    to: config.reminderRecipients,\n    subject: \"Reminder: No Newsletter Content This Week\"\n  });\n}\n```\n\n### Database Schema\n```sql\nCREATE TABLE newsletters (\n  id TEXT PRIMARY KEY,\n  html_content TEXT,\n  status TEXT DEFAULT 'pending',\n  file_id TEXT,\n  created_at TIMESTAMP,\n  sent_at TIMESTAMP\n);\n\nCREATE TABLE processed_files (\n  file_id TEXT PRIMARY KEY,\n  file_name TEXT,\n  processed_at TIMESTAMP DEFAULT NOW()\n);\n```"}
{"instruction": "Hur hanterar jag errors och edge cases i n8n workflows?", "output": "## Error Handling i n8n Workflows\n\n### 1. Server Health Check Pattern\n```javascript\n// Kolla server status innan main flow\n{\n  url: \"{{ $('Config').json.statusCheckUrl }}\",\n  options: { timeout: 5000 }\n}\n\n// If-nod: statusCode === 200\n// True → Continue\n// False → Send Error Alert\n```\n\n### 2. Idempotency Pattern\n```sql\n-- Kolla om redan processad\nSELECT COUNT(*) as count FROM processed_items WHERE id = $1\n\n-- If count > 0 → Skip\n-- Else → Process och INSERT\n```\n\n### 3. HTTP Request Error Handling\n```javascript\n{\n  options: {\n    response: {\n      response: {\n        neverError: true  // Returnera error som data istället för att faila\n      }\n    }\n  }\n}\n```\n\n### 4. Fallback Values\n```javascript\n// Säkra expressions med fallbacks\n$json.value || $json.defaultValue || 'fallback'\n$json.nested?.deeply?.value ?? 'default'\n```\n\n### 5. Error Webhook Alerts\n```javascript\n// Send Error Alert nod\n{\n  method: \"POST\",\n  url: \"{{ config.alertWebhookUrl }}\",\n  body: {\n    timestamp: \"{{ $now.toISO() }}\",\n    error: \"{{ $json.error }}\",\n    workflow: \"Workflow Name\",\n    node: \"{{ $node.name }}\"\n  }\n}\n```\n\n### 6. Retry Logic\n```javascript\n// Använd n8n's inbyggda retry\n{\n  retryOnFail: true,\n  maxTries: 3,\n  waitBetweenTries: 1000\n}\n```\n\n### 7. Data Validation\n```javascript\n// Code Node validation\nconst required = ['email', 'name', 'amount'];\nconst missing = required.filter(field => !$json[field]);\n\nif (missing.length > 0) {\n  throw new Error(`Missing fields: ${missing.join(', ')}`);\n}\n```\n\n### 8. Graceful Degradation\n```javascript\n// Switch med fallback output\n{\n  rules: [...],\n  options: {\n    fallbackOutput: 0  // Default route om ingen regel matchar\n  }\n}\n```"}
{"instruction": "Hur optimerar jag n8n workflows för prestanda?", "output": "## n8n Performance Optimization\n\n### 1. Batch Processing\n```javascript\n// Använd SplitInBatches för stora datasets\n{\n  batchSize: 100,\n  options: { reset: false }\n}\n\n// Eller Loop Over Items\nfor (const item of $input.all()) {\n  // Process\n}\n```\n\n### 2. Parallel Execution\n```javascript\n// Merge med combineByPosition för parallella branches\n{\n  mode: \"combine\",\n  combineBy: \"combineByPosition\",\n  numberInputs: 5\n}\n```\n\n### 3. Caching\n```javascript\n// Spara resultat i workflow static data\nconst cache = $getWorkflowStaticData('global');\nconst cacheKey = `api_${$json.id}`;\n\nif (cache[cacheKey] && Date.now() - cache[cacheKey].timestamp < 3600000) {\n  return cache[cacheKey].data;\n}\n\n// Fetch and cache\nconst result = await fetch(...);\ncache[cacheKey] = { data: result, timestamp: Date.now() };\n```\n\n### 4. Incremental Sync\n```javascript\n// Spara last sync timestamp\nconst lastSync = $getWorkflowStaticData('global').lastSync || '1970-01-01';\n\n// Query endast nya items\n{\n  filter: `modified_at > '${lastSync}'`\n}\n\n// Uppdatera efter sync\n$getWorkflowStaticData('global').lastSync = $now.toISO();\n```\n\n### 5. Minimize API Calls\n```javascript\n// Batch API requests\nconst ids = items.map(i => i.json.id);\nconst response = await fetch(`/api/items?ids=${ids.join(',')}`);\n\n// Istället för\nfor (const item of items) {\n  await fetch(`/api/items/${item.json.id}`); // Långsamt!\n}\n```\n\n### 6. Response Size\n```javascript\n// Begränsa returnerade fält\n{\n  options: {\n    fields: \"id,name,status\"  // Bara nödvändiga fält\n  }\n}\n```\n\n### 7. Timeout Configuration\n```javascript\n// Sätt rimliga timeouts\n{\n  options: {\n    timeout: 30000  // 30 sekunder\n  }\n}\n```\n\n### 8. Memory Management\n```javascript\n// Rensa stora objekt efter användning\ndelete $json._original;\ndelete $json.largePayload;\n\n// Använd streaming för stora filer\n{ responseFormat: \"file\" }\n```"}
{"instruction": "Skapa webhooks med authentication och response handling i n8n", "output": "## n8n Webhook Patterns\n\n### 1. Basic Authenticated Webhook\n```javascript\n{\n  httpMethod: \"POST\",\n  path: \"my-webhook\",\n  authentication: \"headerAuth\",  // Kräver credentials\n  responseMode: \"responseNode\",  // Manuell response\n  options: {}\n}\n```\n\n### 2. Response Modes\n```javascript\n// responseMode options:\n// - \"onReceived\": Svara direkt med 200\n// - \"lastNode\": Svara efter sista noden\n// - \"responseNode\": Använd Respond to Webhook nod\n\n// Respond to Webhook\n{\n  respondWith: \"json\",\n  responseBody: \"={{ $json }}\",\n  options: {\n    responseCode: 200,\n    responseHeaders: {\n      \"X-Custom-Header\": \"value\"\n    }\n  }\n}\n```\n\n### 3. Request Parsing\n```javascript\n// Webhook data locations\n$json.body       // POST body\n$json.query      // Query parameters\n$json.headers    // Request headers\n$json.params     // URL parameters\n\n// Multipart form data\n$json.body.field_name\n$binary.file     // Uploaded file\n```\n\n### 4. Validation Pattern\n```javascript\n// Code Node efter webhook\nconst required = ['action', 'data'];\nconst body = $json.body;\n\nfor (const field of required) {\n  if (!body[field]) {\n    return {\n      json: {\n        error: `Missing required field: ${field}`,\n        statusCode: 400\n      }\n    };\n  }\n}\n\nreturn { json: { ...body, validated: true } };\n```\n\n### 5. Webhook URL Format\n```\nProduction: https://your-n8n.com/webhook/path-name\nTest: https://your-n8n.com/webhook-test/path-name\n```\n\n### 6. Error Response\n```javascript\n// Respond to Webhook för errors\n{\n  respondWith: \"json\",\n  responseBody: {\n    success: false,\n    error: \"{{ $json.errorMessage }}\",\n    code: \"{{ $json.errorCode }}\"\n  },\n  options: {\n    responseCode: 400\n  }\n}\n```\n\n### 7. Async Processing\n```javascript\n// Svara direkt, processa i bakgrunden\n// 1. Webhook med responseMode: \"onReceived\"\n// 2. Async processing continues\n// 3. Callback webhook när klart\n```"}
